# DDD 领域模型

## 基本概念

* 实体：以 Id 判断同一对象的领域对象
* 值对象：表示一个值，用于描述实体属性
* 聚合：由若干实体和值对象组成的概念上的整体
* 关联：领域对象之间的关系

此外也会用到以下概念

* 库：对聚合进行数据库存取
* 工厂：创建复杂的聚合
* 领域服务：表达难以在一个聚合中完成的业务逻辑



### 实体和值对象

实体值对象统称领域对象

| 实体               | 值对象               |
| ------------------ | -------------------- |
| 具有唯一标识（ID） | 没有唯一标识（ID）   |
| 具有生命周期       |                      |
| 通过ID判断统一性   | 通过属性值判断同一性 |
| 可变               | 不可变               |
| 比如“人”、“订单”   | 比如“金额”、“地址”   |



### 聚合

聚合是若干领域对象组成的概念上的整体，并封装了这些额领域对象中的业务逻辑，包括

* 聚合根
  * 是聚合的根节点，其本身是一个实体，负责维护聚合整体的一致性，以及外界对聚合的访问
* 非聚合根的领域对象
  * 是聚合内的细节，可以是实体和值对象

#### 聚合的规则

* 聚合根有全局标识。非聚合根实体具有局部标识，在聚合内唯一
* 聚合边界外的对象只能持有聚合根，不能持有聚合内对象的引用
* 边界内的对象可以持有对其他聚合根的引用
* 删除聚合根的话，聚合中所有对象都被删除
* 聚合内任何对象发生改变，都不能违反聚合的整体业务规则
* 聚合确定事务边界
* 聚合作为整体进行持久化和查询



### 关联

关联表示领域对象之间的关系，分为以下几种

* 一对一
* 一对多
* 多对多
* 泛化（分类）



### 库

* 每个聚合一个 Repository
* 单独的实体，可以看作“退化”的聚合，也有一个 Repository
* 逻辑上对聚合进行整体数据库存取（增删改查）
* 可采用延迟加载技术
* 领域层放接口，基础设施层放实现，实现“依赖倒置”原则



### 工厂

对于复杂的聚合，使用专门的工厂对象来创建，而不是直接用构造器。从而将创建逻辑从聚合中剥离出来



### 领域服务

对于难以放入单独的聚合，活放入单独聚合显得不自然的领域逻辑，使用单独的领域服务对象。例如“转账”



## 发布单元设计

#### 发布单元是系统运行和部署的最小单元

* 依据业务界限上下文划分
  * 在业务层面实现了高内聚和低耦合
  * 在颗粒度上是比较适合刚刚开始做服务化架构的团队能力的
* 按照组织结构划分
  * 依照康威定律来划分服务
  * 按照变更的频率拆分
    * 可以按照系统功能中不同的变更频率来划分，通常来说，越靠近终端用户的特性变更频率越高，反之越低
  * 按照技术异构的边界划分
    * 按照不同的技术选型发展方向来划分系统
  * 按照业务对于伸缩性或者健壮性的不同要求划分
  * 按照企业对于安全性的不同要求划分

#### 发布单元就是微服务架构中的服务

每条业务做到4个独立

* 独立进程
  * 以开发一组小型服务的方式来开发一个独立的应用系统，期货总没给小型服务都运行在自己的进程中
* 独立部署
  * 服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署
* 独立技术
  * 每条业务线可以使用不同的开发语言、数据存储技术，并保持最低限制的集中式管理
* 独立团队
  * 每条业务线均配备开发、测试、运维、DBA等更具生产力、更对结果负责的全功能团队

#### 注意事项

* 界限上下文分析结果（具有强二义性的两个上下文尽量不放在一个发布单元中）
* 领域模型的聚合设计结果（聚合不可拆分道不同发布单元中）
* 开发团队的组织方式（康威定律/逆康威定律）



## API 设计

### 界限上下文接口识别

界限上下文以接口形式公开提供给消费方业务能力

* 上下文中的每个命令可能对应着一个接口
* 针对命令，对上下文进行走查，如果上下文间存在调用关系，则被调用方应提供相应的接口
* 补充查询功能的接口
* 补充缺失的其他具有业务价值的接口
* 识别接口的输入输出信息
* 按上下文列出接口

注意：到底采用那种接口设计风格属于实现细节，在接口能力识别的时候不应过早考虑

### 示例

| 上下文   | 接口能力 | 输入           | 输出     |
| -------- | -------- | -------------- | -------- |
| 订单     | 下单     | 订单信息       | 操作状态 |
|          | 获取订单 | 订单号         | 订单信息 |
|          | 撤单     | 订单号         | 操作状态 |
| 售后服务 | 退货     | 订单、订购商品 | 操作状态 |

### 同步调用

指客户端请求需要服务端即时响应，甚至可能由于等待而阻塞

它比较男单，一致性强。但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候

* RESTful（HTTP）：更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能被支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用
* RPC：传输协议更高效，更安全可控，特别在一个公司内部，如果有统一一个的开发规范和统一的服务框架时，它的开发效率优势更明显

推荐使用 RESTful 形式调用，因为这样后期想把 API 对外开放时，可以直接开放

### 异步消息

#### 优势

* 解耦客户端和服务端
* 消息缓冲，确保消息积压不会冲垮被调用方
* 提升调用方的服务体验，不会被其他服务拖慢

代价

* 接收数据最终一致性
* 后台服务要实现幂等性，保证消息的被收到且仅收到一次对性能是很大的考验
* 额外的操作复杂性，消息系统需要单独安装、配置和部署。消息代理必须高可用，否则系统可靠性将受到影响



## 分层架构

#### 展现层（Presentation）

负责与客户端的输入输出（具体技术相关）

* 功能：输入输出
* 内容：Controller，Listener
* 与输入输出技术相关
* 功能和技术举例
  * REST API/SOAP API
  * JSP
  * 消息监听处理
* 执行过程
  * 将技术相关的请求转化成技术无关的请求
  * 调用应用层完成业务功能
  * 将应用层的返回值转化成客户端需要的形式返回客户端
* 与应用层的接口数据可以使领域对象、DTO 或 Mao
* 与客户端的接口数据可以是 DTO 或 Map

#### 应用层（Application）

向展示层提供应用功能（具体技术无关）

* 功能
  * 封装系统功能，对应于 Use Case
  * 确定事务边界
  * 权限管理、记录日志等
* 内容：Application Service
* 与具体技术无关
* 执行过程（以修改一个实体为例）
  * 调用 Repository 得到该实体
  * 根据输入参数修改实体
  * 调用领域层进行校验等领域逻辑
  * 调用 Repository 保存实体
  * 调用 Domain Service 与其他界限上下文沟通
* 与领域层的接口为领域对象

#### 领域层（Domain）

领域模型和领域逻辑（具体技术无关）

* 功能：封装领域对象和领域逻辑，处于系统的核心
* 内容：领域模型
  * Aggregate（聚合）
  * Entity（实体）
  * Value Object（值对象）
  * Factory（工厂）
  * Repository（仓库，只放接口）
  * Domain Service（领域服务）
    * 难以分配到单一聚合或实体的领域逻辑
    * 对其他界限上下文的调用（只放接口）
  * Domain Event（领域事件）
* 与具体技术无关
* 一般不依赖于其它层，而是被其它层依赖
* 一般按 Aggregate 分包

#### 基础设施层（Infrastructure）

访问外部资源（具体技术相关）

* 功能：调用外部资源和服务的特定技术实现
* 内容
  * Repository的实现
    * 以 Aggregate 为单位
    * 通常返回领域对象
    * 对于纯查询功能，可返回 DTO
  * 调用其他界限上下文的实现
* 采用依赖倒置原则
* 与展现层相同点
  * 与具体技术相关，相当于六边形架构中的“适配器”层
* 与展现层的区别（方向不同）
  * 展现层相应外部调用
  * 基础设置是层发起向外部的调用