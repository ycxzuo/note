# 垃圾收集

## 垃圾收集器实现算法

### 引用计数

* C++ 共享指针（记录被引用的次数，也有 GC ROOTS）
* 独立循环

### 标记与清理

* 垃圾收集根对象
  * 局部变量
  * 活动线程
  * 静态域
  * JNI 引用

JVM 利用标记与清理算法，跟踪所有可达对象，并确保从不可达对象中释放的内存空间能够再次被使用，该算法包含两个步骤

* 标记：从 GC 根对象开始遍历所有可达对象，并且在本地内存中保持对象的分类
* 清理：确保那些被不再可达的对象占据的内存能够下次分配复用



## 概念

### 职责

* 分配内存
* 确保被引用的对象保留在内存
* 回复那些引用不再可达的对象所占用的内存



### STW

stop the world，在 GC 进行的时候防止产生新的垃圾或者被标记的垃圾又被引用，所以会停止运行，考虑因素有三点

* 时间
* 空间
* 频率



### 特征

* 安全和全面
* 执行效率
* 限制内存碎片
* 伸缩性



### 性能指标

* 吞吐量
* 垃圾收集开销
* 停顿时间
* 收集频率
* 内存印记
* 敏捷



### 分代收集

将堆分成三部分，新生代、老年代和永久带（元空间）



#### 新生代

由 Eden + S0 + S1 组成

调整参数为 -Xmn

##### Eden 区

初始化分配大多数对象（少量大对象直接晋升老年代）

可划分为一个或多个 Thread Local Allocation Buffer（TLAB），利用线程划分 Eden 区，避免线程安全问题并提升性能，因为不需要用到锁

##### survivor 区

由 from 和 to 两个空间组成，同一时间总有一个空间为空

存放至少经历过一次 GC 的对象，超过一定次数会提升到老年代，次数调整 `-XX:+MaxTenuringThreshold`，默认 15 次



#### 老年代

存储：经历多次 GC

GC：实现复杂，次数较少，垃圾概率小，标记所有通过 GC Roots 可达的对象

空间：较大，最大值 = `-Xmx` - `-Xmn`



#### 永久代

存储：元数据，如 Class 信息， String.intern() 对象

GC: FGC 将回收该区域

空间：非堆区域，`-XX:MaxPermSize`

异常：java.lang.OutOfMemoryError: Permgen space

场景：Java 8 开始移除该区域，使用 Metaspace



#### 元空间

存储：元数据，如 Class 信息， String.intern() 对象

GC: FGC 将回收该区域

空间：非堆区域，本地内存，受限于 Java 进程可用的本地内存，`-XX:MaxMetaspaceSize`

场景：Java 8 开始引入



### GC 事件

Minor GC：新生代

Major GC：老年代

Full GC：整个堆 + 永久代



## 概览

### 垃圾收集器实现

* Serial
* Parallel
* Parallel Compacting
* Concurrent Mark-Sweep（CMS）
* G1
* Shenandoah