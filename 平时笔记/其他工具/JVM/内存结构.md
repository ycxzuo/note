# 内存结构

### 堆 heap

随着虚拟机的启动而创建，JVM 会自动进行垃圾回收，不支持手动回收（与 C 的 free(data) 方法不同）



虚拟机设置堆信息参数

* `-Xms` 初始堆大小
* `-Xmx` 最大堆大小
* `-Xmn` 设置年轻代大小



### 栈 stack

#### 组成结构

##### 局部变量表

存放`方法参数`和`局部变量`的存储空间，方法表中 Code 属性的 max_locals 指定了方法所需的最大容量。基本单位为 `slot`，并且 `slot` 可以重用。非静态方法调用时，局部变量表中索引为 0 的 `slot` 默认为传递方法所属的实例引用（this）

##### 操作数栈

每一栈用于存储任意类型的数据的值，虚拟机会优化，是两个操作数栈有部分重叠，公用部分数据

##### 动态链接

支持方法调用的时候动态连接方法所在类的运行时常量池引用

##### 返回地址

方法返回值传递给哪个地址



#### 特性

随着线程的创建而创建，因为报错的时候可以看见整个报错的栈信息

```java
private static final StackTraceElement[] EMPTY_STACK_TRACE = new StackTraceElement[0];
private static native StackTraceElement[][] dumpThreads(Thread[] threads);
```

由上述代码可见，线程的栈信息是存在 JVM 里面，需要用 native 方法去拿

线程创建的时候栈大小默认是根据虚拟机启动参数 `-Xss` 指定，也可以在线程创建的时候在构造函数动态指定栈的大小



### 方法区 method area



### 本地方法栈 Native Method Stack

随着线程的创建而创建，是非 Java 编写的部分



### 程序计数器（PC 寄存器）



### 非堆

#### metaspace

#### code cache

JVM 生成的 native code 存放的内存空间称之为 Code Cache；JIT 编译、JNI 等都会编译代码到 native code，其中 JIT 生成的 native code 占用了 Code Cache 的绝大部分空间

#### method area

#### runtime constant pool



## 内存管理

### 分类

* 手动内存管理：API 调用（如 C 的 malloc 和 free）
* 自动内存管理：垃圾收集器
