# 问题记录

## 异常

### invocationtargetexception

很明显是反射的问题，但是是哪里用到了反射呢？很明显，业务代码一般不会用到代码，Spring 也只用到了 IoC，如果有问题应该在初始化就有问题，所以就考虑到是不是 mybatis，随后发现是方法中传入对象没有用注解 `@Param`，导致调用反射异常



### ConcurrentModificationException

#### 并发的问题，报错操作是

```java
Map<String, String> map = new HashMap<>();
map.put("a","1");
map.put("b","2");
map.keySet().forEach(map::remove);
//或者 for 循环也是一样的效果
```



#### 解析

先看源码

```java
final class KeySet extends AbstractSet<K> {
    public final int size()                 { return size; }
    public final void clear()               { HashMap.this.clear(); }
    public final Iterator<K> iterator()     { return new KeyIterator(); }
    public final boolean contains(Object o) { return containsKey(o); }
    public final boolean remove(Object key) {
        return removeNode(hash(key), key, null, false, true) != null;
    }
    public final Spliterator<K> spliterator() {
        return new KeySpliterator<>(HashMap.this, 0, -1, 0, 0);
    }
    public final void forEach(Consumer<? super K> action) {
        Node<K,V>[] tab;
        if (action == null)
            throw new NullPointerException();
        if (size > 0 && (tab = table) != null) {
            int mc = modCount;
            for (Node<K,V> e : tab) {
                for (; e != null; e = e.next)
                    action.accept(e.key);
            }
            if (modCount != mc)
                throw new ConcurrentModificationException();
        }
    }
}
```

源码很清楚，在使用 `forEach()`  的时候是不允许对其进行增删的，KeySet 、Values 和 EntrySet 都是如此



#### 解决方案

使用 Iterator 去删除元素

```java
Map<String, String> map = new HashMap<>();
map.put("a","1");
map.put("b","2");
// 底层使用的是 Collection 的 Iterator 删除
map.entrySet().removeIf(entry -> map.keySet().contains(entry.getKey()));
```

