# 学习笔记

## JDK

### Integer

* JVM会自动维护八种基本类型的常量池，int常量池中初始化`-128~127`的范围，所以当`Integer i = 127`时，在自动装箱时是取得常量池中的数值，而`Integer = 128`时，自动装箱过程中new一个128。

### Arrays

* `java.util.Arrays`中有自己封装的私有的ArrayList静态内部类

  ```java
  private static class ArrayList<E> extends AbstractList<E>
          implements RandomAccess, java.io.Serializable{
      private static final long serialVersionUID = -2764017481108945198L;
      private final E[] a;
  
      ArrayList(E[] array) {
          a = Objects.requireNonNull(array);
      }
     ...
  }
  ```

  以上原因导致下面的代码不一致

  ```java
  public class demo1 {
      public static void main(String[] args) {
          Integer[] arr1 = {1,2,3,4,5,6};
          int[] arr2 = {1,2,3,4,5,6};
  
          System.out.println(Arrays.asList(arr1).size());//6
          System.out.println(Arrays.asList(arr2).size());//1
      }
  }
  ```

  为什么会出现这个问题呢？

  在`Arrays.asList(arr1)`-> `Arrays$ArrayList(Integer[]{arr1})`

  在`Arrays.asList(arr2)`-> `Arrays$ArrayList(new int[][]{arr2})`



### Reflect

#### Class

- `getSuperclass()`返回的是直接父类的类型，**不包括泛型参数。**
- `getGenericSuperclass()`返回的是**包括泛型参数**在内的直接父类。
- 注意如果父类声明了泛型，但子类继承时没有为父类实现该泛型，这时候也是没有泛型参数的。

#### ParameterizedType (Type 接口的子接口,表示参数化的类型,即实现了泛型参数的类型)

##### 特性：

- 如果直接用对象实例 `instanceof ParameterizedType`，结果都是false。
- Class对象不能`instanceof ParameterizedType`，编译会报错。
- 只有用 Type 对象`instanceof ParameterizedType`才能得到想要的比较结果。
- 实现泛型参数，可以是给泛型传入了一个真实的类型，或者传入另一个新声明的泛型参数；只声明泛型而不实现，`instanceof ParameterizedType`为`false`。

##### 方法

* `getRawType()`返回声明了这个类型的类或接口，也就是去掉了泛型参数部分的类型对象
* `getActualTypeArguments()`以数组的形式返回泛型参数列表
  * 当传入的是真实类型时，打印的是全类名。
  * 当传入的是另一个新声明的泛型参数时 ，打印的是代表该泛型参数的符号
* `getOwnerType()`如果该类型是一个内部类/接口，返回它的外部类/接口。如果该类型不是内部类/接口，返回null

