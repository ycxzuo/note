# 垃圾回收机制

## 概述

Java虚拟机内存的动态分配和垃圾收集机制已经非常成熟.程序计数器,虚拟机栈,本地方法区的生命周期是随着线程共生死的,所以这三个区域的垃圾回收都不会存在问题.但是Java堆和方法区,只有在程序运行的时候才知道会创建哪些对象,这部分内存的分配和回收都是动态的.

## 判断对象可以被回收

### 引用计数法

* 定义
  * 给对象添加一个引用计数器,被引用时就+1,引用失效时就减一.当引用计数为0时被回收掉.
* 缺陷
  * 对于循环引用的对象无法进行回收.

### 可达性分析

- 定义
  - 通过一系列"GC Roots"的对象作为起点,从这些节点开始往下搜索,搜索所走过的路叫做引用链.当然一个对象没有任何引用链相连,那么就会被GC回收掉.
- GC Roots
  - 虚拟机栈(栈桢中本地变量表)中的引用对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中的JNI(即一般说的Native方法)引用的对象



## 引用

- 定义
  - JDK1.2之前
    - 如果reference存储的数值代表的另一个内存的起始地址,就称这块内存代表的一个引用.
    - 缺陷: 一个对象只有两个状态,一个被引用,一个未被引用.但是当内存空间足够空闲,对于有些对象其实也可以保留.直到内存空间紧张时再回收这些对象.
  - JDK1.2之后
    - 对引用进行了扩充,将引用分为强引用(Strong Reference),软引用(Soft Reference),弱引用(Weak Reference),虚引用(Phantom Reference).四种引用强度依次减弱.
    - **强引用**: 程序代码中普遍存在的,如`Object obj = new Object()`.如果是强引用,垃圾收集器永远不会回收掉被引用的对象.
    - **软引用**: 描述一些还有用但非必须的对象.软引用的对象,在系统将要发生内存溢出的情况之前,将会把这些对象列入回收范围之内,进行第二次回收,如果还不够,则会抛出OOM.提供`SoftReference`类来实现
    - **弱引用**: 也是描述一些还有用但非必须的对象,它的强度比软引用的弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生之前.提供`WeakReference`类来实现
    - **虚引用**: 也被称为幽灵引用或者幻影引用.唯一的作用就是让这个对象被垃圾收集器回收时收到一个系统通知`PhantomReference`类来实现.



## 生存还是死亡

即使在可达性分析算法中不可达的对象,也不一定会被回收,只是出于准备被回收的阶段,真正宣告"死亡"的对象至少要经历两次标记过程.如果发现对象在可达性分析后发现没有与GC Roots相连的引用链,那么他将被第一次标记并进行一次筛选,筛选的条件是该对象是否有必要执行`finalize()`方法,当对象没有覆盖`finalize()`方法或者虚拟机已经调用过`finalize()`方法,虚拟机认为这两种方法都"没有必要执行".

如果这个对象被判定为有必要执行`finalize()`方法,那么这个对象将会被放入一个叫做F-Queue的队列中,稍后会由虚拟机自动创建的,低优先级的`Finalizer`线程去执行它.所谓的执行是指虚拟机会触发这个方法,但并不承诺会等待它运行结束(原因是如果`finalize()`方法执行缓慢或者发生了死循环,会导致F-Queue队列中的对象永久的等待,最终导致整个内存回收系统崩溃).`finalize()`方法是对象逃脱死亡的最后一次机会,稍后GC将对F-Queue中的对象进行小规模的标记,如果对象要在`finalize()`方法中拯救自己——重新与引用链上的任何对象建立关联即可,譬如把自己(this关键字)赋值给某个类或者对象的成员变量,那么就会在第二次标记时移出F-Queue队列;若在第二次标记时没有成功逃脱,则该对象就被真正的回收了.

对象执行过`finalize()`方法后就不会再被执行.

* 建议
  * 这个方法不要使用,因为不确定因素太多,可以用try/catch/finally来关闭资源.



## 回收方法区

永久带垃圾回收包括两个部分内容: 

* 废弃的常量
  * 回收常量和Java堆中回收对象类似.
* 无用的类



