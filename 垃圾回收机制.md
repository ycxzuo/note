# 垃圾回收机制

## 概述

Java虚拟机内存的动态分配和垃圾收集机制已经非常成熟.程序计数器,虚拟机栈,本地方法区的生命周期是随着线程共生死的,所以这三个区域的垃圾回收都不会存在问题.但是Java堆和方法区,只有在程序运行的时候才知道会创建哪些对象,这部分内存的分配和回收都是动态的.

## 判断对象可以被回收

### 引用计数法

* 定义
  * 给对象添加一个引用计数器,被引用时就+1,引用失效时就减一.当引用计数为0时被回收掉.
* 缺陷
  * 对于循环引用的对象无法进行回收.

### 可达性分析

- 定义
  - 通过一系列"GC Roots"的对象作为起点,从这些节点开始往下搜索,搜索所走过的路叫做引用链.当然一个对象没有任何引用链相连,那么就会被GC回收掉.
- GC Roots
  - 虚拟机栈(栈桢中本地变量表)中的引用对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中的JNI(即一般说的Native方法)引用的对象



### 引用

- 定义
  - JDK1.2之前
    - 如果reference存储的数值代表的另一个内存的起始地址,就称这块内存代表的一个引用.
    - 缺陷: 一个对象只有两个状态,一个被引用,一个未被引用.但是当内存空间足够空闲,对于有些对象其实也可以保留.直到内存空间紧张时再回收这些对象.
  - JDK1.2之后
    - 对引用进行了扩充,将引用分为强引用(Strong Reference),软引用(Soft Reference),弱引用(Weak Reference),虚引用(Phantom Reference).四种引用强度依次减弱.
    - **强引用**: 程序代码中普遍存在的,如`Object obj = new Object()`.如果是强引用,垃圾收集器永远不会回收掉被引用的对象.
    - **软引用**: 描述一些还有用但非必须的对象.软引用的对象,在系统将要发生内存溢出的情况之前,将会把这些对象列入回收范围之内,进行第二次回收,如果还不够,则会抛出OOM.提供`SoftReference`类来实现
    - **弱引用**: 也是描述一些还有用但非必须的对象,它的强度比软引用的弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生之前.提供`WeakReference`类来实现
    - **虚引用**: 也被称为幽灵引用或者幻影引用.唯一的作用就是让这个对象被垃圾收集器回收时收到一个系统通知`PhantomReference`类来实现.



### 生存还是死亡

即使在可达性分析算法中不可达的对象,也不一定会被回收,只是出于准备被回收的阶段,真正宣告"死亡"的对象至少要经历两次标记过程.如果发现对象在可达性分析后发现没有与GC Roots相连的引用链,那么他将被第一次标记并进行一次筛选,筛选的条件是该对象是否有必要执行`finalize()`方法,当对象没有覆盖`finalize()`方法或者虚拟机已经调用过`finalize()`方法,虚拟机认为这两种方法都"没有必要执行".

如果这个对象被判定为有必要执行`finalize()`方法,那么这个对象将会被放入一个叫做F-Queue的队列中,稍后会由虚拟机自动创建的,低优先级的`Finalizer`线程去执行它.所谓的执行是指虚拟机会触发这个方法,但并不承诺会等待它运行结束(原因是如果`finalize()`方法执行缓慢或者发生了死循环,会导致F-Queue队列中的对象永久的等待,最终导致整个内存回收系统崩溃).`finalize()`方法是对象逃脱死亡的最后一次机会,稍后GC将对F-Queue中的对象进行小规模的标记,如果对象要在`finalize()`方法中拯救自己——重新与引用链上的任何对象建立关联即可,譬如把自己(this关键字)赋值给某个类或者对象的成员变量,那么就会在第二次标记时移出F-Queue队列;若在第二次标记时没有成功逃脱,则该对象就被真正的回收了.

对象执行过`finalize()`方法后就不会再被执行.

* 建议
  * 这个方法不要使用,因为不确定因素太多,可以用try/catch/finally来关闭资源.



### 回收方法区

永久带垃圾回收包括两个部分内容: 

* 废弃的常量(字符串,类(接口),方法,字段的符号引用)
  * 回收常量和Java堆中回收对象类似.
* 无用的类(需要同时满足三个要求)
  * 该类所有的实例已经被回收
  * 加载该类的ClassLoad已经被回收
  * 该类对应的java.lang.Class没有在任何地方引用,无法在任何地方通过反射访问该类的方法

无用的类并不一定会被回收,虚拟机提供了`-Xnoclassgc`参数来控制这一行为,使用`-verbose:class`以及`-XX:TrackClassLoading`(需要Product版的虚拟机使用),`-XX:TrackClassUnLoading`(需要FastDebug版的虚拟机支持)查看类加载和类卸载的信息.



## 垃圾收集算法(偏理论)

### 标记-清除算法

* 定义
  * 首先标记出需要回收的对象,然后统一回收被标记的对象.在"生存还是死亡"章节已经详细说明.
* 缺陷
  * **效率问题**: 标记和清除效率都不高
  * **空间问题**: 清除后会产生不连续的内存片段,在需要分配较大对象时不得不触发垃圾收集动作.



### 复制算法

* 定义
  * 将内存按容量分为两块,只是用其中一块,当内存将要存满时,将存活的对象复制到另一块内存中,并清除该内存区域.
* 优点
  * 实现简单
  * 运行高效
* 缺陷
  * 将可用内存缩小为原来的一半.
  * 当内存存活率高的时候,效率会变低.
  * 需要有额外空间进行担保.



### 复制算法的优化

* 定义
  * IBM的专门研究表明,新生代中98%的对象都是"朝生夕死",所以将内存划分为一块较大的Eden空间和两块较小的Survivor空间.当回收时,将Eden和Survivor中存活的对象一次性复制到另一块Survivor上,然后清理用过的内存.默认Eden:Survivor=8:1,这样,只有10的内存空间被浪费.如果回收的对象大于Survivor内存空间大小(10%),需要依其他内存空间(老年区)进行分配担保.



### 标记-整理算法

* 定义
  * 根据老年代的特点(对象存活时间久)提出的.他与标记-清除算法相似,只是不是直接对可回收的对象进行清理,而是让所有存活的对象移至一端,然后清理边界以外的内存.



### 分代收集算法

* 定义
  * 没有什么新思想,只是根据存活周期的不同将内存分为几块.一般是把Java堆分成新生代和老年代.可以根据不同的年龄代采取不同的收集算法.新生代一般使用复制算法,而老年代一般使用标记-清除算法或者标记-整理算法.



## HotShot的算法实现

### 枚举根节点

从可达性分析中从GC Roots节点找引用链这个操作为例

* **引用多**: 可作为GC Roots节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈桢中的本地变量表)中,现在很多应用仅仅方法区就有几百兆,如果要逐个检查这个里面的引用,必然会消耗很多时间.
* **GC停顿**: 可达性分析操作必须保证在一个确保一致性的快照(整个分析期间,整个执行系统就像被冻结在某个时间点上,不可以出现分析过程中,整个对象的引用还在不断的变化,不满足该点的话,分析结果的准确性就不能得到保证)中进行.这点将会导致GC进行时必须停顿所有的Java的执行线程(Sun公司称其为*Stop The World*)的其中一个重要原因.

由于HotShot是准确式GC,所以并不需要一个不漏的检查完所有的全局性应用和执行上下文的引用位置,它使用一组称为OopMap的数据结构来存放,类加载完成的时候,HotShot就把对象内的什么偏移量上是什么类型的数据计算出来,在JIT编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用.



### 安全点

可能导致引用变化或者说OopMap内容变化的指令特别多,如果对每一条指令都生成一个OopMap,那么将需要大量的额外空间,这样GC的成本会非常高.

* 定义
  * 实际上HotShot的确也没有为每条指令都生成OopMap,之前也提到是在**特定位置**记录了这些信息,这些位置称为**安全点(Safepoint)**.程序执行时并非在所有地方都能停顿下来GC,只有到达安全点才能暂停.
* 选定
  * 既不能太少以至于GC等待时间过长,也不能过于频繁,增加运行时的负荷.其选择是基于**"是否让程序长时间执行的特征"**为标准进行选定的——因为每条指令执行的时间都非常短,程序不太可能因为指令流太长这个原因而过长时间运行,"长时间执行"的最明显特征就是指令序列复用,例如方法调用,循环跳转,异常跳转等,所以具有这些功能的指令才会产生Safepoint.