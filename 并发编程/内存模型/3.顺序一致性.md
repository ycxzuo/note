# 顺序一致性

顺序一致性h内存模型是一个理论参考模型



## 数据竞争与顺序一致性

当程序未正确同步时，可能会出现数据竞争

java 内存模型规范对数据竞争的**定义**如下

在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序



## 顺序一致性模型

是一个被计算机科学家理想化了的理论参考模型

### 两大特性

* 一个线程中所有操作必须按照程序的顺序来执行
* （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见

概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的执行顺序来执行内存读/写操作

> 例如：
>
> 线程1: A1 -> A2 -> A3
>
> 线程2: B2 -> B2 -> B3
>
> 假设这两个线程使用监视器锁来正确同步：线程1 的 3 个操作执行完后释放监视器锁，随后 线程2 获取同一个监视器锁，那么执行结果一定是 A1 -> A2 -> A3 -> B1 -> B2 -> B3



## 同步程序的顺序一致性效果

对重定向代码使用锁来同步

```java
class ReorderExample {
    int a = 0;
    boolean flag = false;
    
    public synchronized void writer() { // 获取锁
        a = 1;				//1
        flag = true;		//2
    }									// 释放锁
    
    public synchronized void reader() {	// 获取锁
        if (flag) {			//3
            int i = a * a; 	//4
        }
    }									// 释放锁
}
```

在上述代码中，步骤1 和 步骤2 可以重排序，步骤3 和 步骤4 可以重排序，但是步骤1 和 步骤2 一定在 步骤3 和 步骤4 之前执行



## 未同步程序的执行特性

对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性，为了实现最小安全性，JVM 在堆上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象

未同步程序在 JMM 中执行时，整体上是无序的，期执行结果无法预知

### 总线事务

每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为**总线事务**

* 读事务 - 从内存传送数据到处理器 
* 写事务 - 从处理器传送数据到内存
