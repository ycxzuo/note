# volatile 关键字

## 概念

volatile 是比 synchronized 关键字同步机制更弱一点的同步关键字，它只能修饰变量

### java语言规范定义

java 编程语言允许线程访问共享变量，为确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量



## 特性

* 保证变量对所有线程可见
* 禁止指令重排



## CPU 术语

| 术语       | 英文单词               | 术语描述                                                     |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 内存屏障   | memory barriers        | 是一组处理器指令，用于实现对内存操作的顺序                   |
| 缓冲行     | cache line             | CPU 高速缓存中可以分配的最小存储单位，处理器填写缓存行时会加载整个缓存行 |
| 原子操作   | atomic operations      | 不可中断的一个或一系列操作                                   |
| 缓存行填充 | cache line fill        | 处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当缓存（L1,L2,L3） |
| 缓存命中   | cache hit              | 如果进行高速缓存行填充的内存位置仍然是下次处理器访问的地址，处理器从缓存中读取操作数 |
| 写命中     | write hit              | 处理器将操作数回写到一个内存缓冲区时，这个缓存的内存地址在缓存行中，则回写在缓存区而非内存区 |
| 写缺失     | write misses the cache | 一个有效的缓存行被写入到不存在的内存区域                     |



## volatile 进行写操作时，CPU 做的事

java 代码

```java
volatile Singleton instance = new Singleton();
```

汇编代码

```asm
0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);
```

Lock 前缀的指令在多核处理器下会引发两件事情

* 将当前处理器缓存行的数据回写到系统内存
* 这个协会内存的操作会使其他 CPU 里缓存了该内存地址的数据无效



## MESI 一致性协议

IA-32 和 Inter 64 处理器使用 MESI 控制协议去维护内部缓存和其他处理器缓存的一致性

MESI 是指 4 中状态的首字母。每个 Cache line 有 4 个状态，可用 2 个 bit 表示

* M -> Modified
  * 当前 CPU 刚修改完数据的状态，当前 CPU 拥有最新数据，其他 CPU 拥有失效数据，而且和主存数据不一致
* E -> Exclusive
  * 只有当前 CPU 中有数据，其他 CPU 中没有改数据，当前 CPU 的数据和主存的数据是一致的
* S -> Shared
  * 当前 CPU 和其他 CPU 中都有共同的数据，并且和主存中的数据一致
* I -> Invalid
  * 当前 CPU 中的数据失效，数据应该从主存中获取，其他 CPU 中可能有数据也可能无数据，当前 CPU 中的数据和主存中的数据被认为不一致



## 优化

追加字节填充缓存行

JVM 启动开启`-XX:-RestrictContended` 和 `@sun.misc.Contended`注解类或属性字段分组的 申明，自动填充字节齐缓存行

在并发包中，经常会有这样的优化方式提升性能

### 注意

* 缓存行的大小与处理器有关系
* 需要填充的变量是那种频繁改写的数据



## 使用场景

* 对变量的写操作不依赖当前值
* 不同的 volatile 变量不能互相依赖