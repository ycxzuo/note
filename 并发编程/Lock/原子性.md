# 原子操作

## 概念

原子操作意为不可被中断的一个或一系列操作



## 处理器实现原子操作

首先处理器保证基本的内存操作的原子性。但复杂的内存操作处理是不能自动保证其原子性的，比如夸总线宽度、跨多个缓存行和跨页表的访问。处理器提供**总线锁定**和**缓存锁定**两个机制保证复杂内存操作的原子性



### 通过总线锁保证原子性

处理器提供的一个 `LOCK #` 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。总线锁定把 CPU 和内存间的通信锁住了，是的锁定期间，其他处理器不能操作其他内存地址的数据，所以**总线锁定的开销比较大 **



### 通过缓存锁保证原子性

内存区域如果被缓存在处理器内部缓存汇总，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声明 `LOCK #` 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已锁定的缓存行时，会使缓存行无效

两种情况下处理器**不会使用缓存锁定**

* 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定
* 有些处理器不支持缓存锁定，对于 `Intel486` 和 `Pentium` 处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定 



## Java 如何实现原子操作

在 `Java` 中通过`锁`和`自旋CAS` 的方式来实现原子操作



### 通过 自旋 CAS 实现原子操作

利用死循环加上 Atomic 工作类进行原子操作 

```java
AtomicInteger integer = new AtomicInteger(0);
int i = integer.get();
for(;;) {
    if (integer.compareAndSet(i, ++i) {
        break;
    }
}
```



#### CAS 实现原子操作的三大问题

* ABA 问题
* 自旋时间长开销大
* 只能保证一个共享变量的原子操作



### 通过锁机制实现原子操作

锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM 内部实现了很多种锁机制，如偏向锁、轻量级锁、重量级锁和互斥锁