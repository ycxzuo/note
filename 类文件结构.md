# 类文件结构

## 概述

计算机只认识0和1，将我们编写的程序编译成二进制本地机器码已不再是唯一选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式

## 无关性

Java诞生之时曾经提出过著名的宣传口号：”Write Once, Run Anywhere".虚拟机可以载入和执行统一中平台无关的字节码来实现这个口号。各种虚拟机与所有平台都同意使用的程序存储格式——字节码（ByteCode）。Java虚拟机不和任何语言绑定，只与“Class文件”这种特定的二进制文件格式所关联，虚拟机不关心Class的来源

## Calss类文件的结构

* Class定义

  * Class文件以一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中。中间没有添加任何分隔符，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前（Big-Endian：高位字节在地址最低位，与x86等处理器相反）的方式分隔成若干个8位字节进行存储。

* 文件格式

  * 采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型

    * 无符号数

      * 属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节，2个字节，4个字节，8个字节的无符号数，可以用来描述数字，索引引用， 数量值或者按照UTF-8编码狗策划给你字符串值。

    * 表

      * 由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性的以“_info”结尾，表用于描述有层次关系的符合结构的数据，整个Class文件本质就是一张表。由下表的数据项构成

      |      类型       |        名称         |         数量          |
      | :-------------: | :-----------------: | :-------------------: |
      |       u4        |        magic        |           1           |
      |       u2        |    minor_version    |           1           |
      |       u2        |    major_version    |           1           |
      |       u2        | constant_pool_count |           1           |
      |     cp_info     |    constant_pool    | constant_pool_count-1 |
      |       u2        |    access_flags     |           1           |
      |       u2        |     this_class      |           1           |
      |       u2        |     super_class     |           1           |
      |       u2        |  interfaces_count   |           1           |
      |       u2        |     interfaces      |   interfaces_count    |
      |       u2        |     field_count     |           1           |
      |   field_info    |       fields        |      field_count      |
      |       u2        |    methods_count    |           1           |
      |   method_info   |       methods       |     methods_count     |
      |       u2        |  attributes_count   |           1           |
      | attributes_info |     attributes      |   attributes_count    |

  * 由于Class的结构没有任何分隔符号，不像XML等描述语言，无论是顺序还是数量，甚至数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的



### 魔数（Magic Number）-> 无符号数

每个Class文件头4个字节称为魔数，他唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不用扩展名来识别的主要原因是基于安全方面的考虑，因为扩展名可以随意的改动。文件格式的制定者可以自由的选择魔数值，只要这个魔数值没有被广泛的使用过又不会引起混淆即可。

### class文件的版本 -> 无符号数

紧接着魔数的4个字节存储的是Class文件的版本号。第5个和第6个字节存储的是次版本号（Minor Version），第7个和第8个字节存储的是主版本号（Major Version）。Java的版本号是从45开始的。

### 常量池 -> 表

紧接着主次版本号之后的是常量池入口，可以理解为Class文件的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据之一。它是Class文件中第一个出现的表类型结构数据项目。

* 常量池容量计数值

  * 由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一个u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数值是从1开始的而不是0，所以常量的数量是计数值-1，索引范围是1~计数值-1。将0空出来是在于满足后面某些指向常量池的索引值的数据在特定的情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就用把索引值置为0，Class文件结构中只有常量池的容量计数是从1开始的。

* 常量池

  * 字面量（Literal）
    * 接近Java中常量的概念，如**文本字符串**、声明为**final的常量值**等
  * 符号引用（Symbolic Reference）
    * 类和接口的全限定名（Fully Qualified Name）
    * 字段的名称和描述符（Descriptor）
    * 方法的名称和描述符

  Java代码在进行Javac编译的时候，不会像C、C++那样有`link`这一步，在虚拟机加载Class文件进行**动态连接**。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因为这些字段、方法的符号引用不经过运行期转换的话，无法得到真正的内存入口地址，也就无法被虚拟机直接使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或者运行时解析、翻译到具体的内存地址之中。

  常量池中每一项常量都是一个表，在JDK1.7之前共有11种结构各不相同的表结构数据，在JDK1.7中由而外增加了3种

  * `CONSTANT_MethodHandle_info`
  * `CONSTANT_MethodType_info`
  * `CONSTANT_InvokeDynamic_info`

  这14种表都有一个共同的特点，就是表的第一位是一个u1类型的标志位（tag），代表当前常量代表哪种类型

  |              类型               | 标志 |           描述           |
  | :-----------------------------: | :--: | :----------------------: |
  |       CONSTANT_Utf-8_info       |  1   |    UTF-8编码的字符串     |
  |      CONSTANT_Integer_info      |  3   |        整型字变量        |
  |       CONSTANT_Float_info       |  4   |       浮点型字变量       |
  |       CONSTANT_Long_info        |  5   |       长整型字变量       |
  |      CONSTANT_Double_info       |  6   |    双精度浮点型字变量    |
  |       CONSTANT_Class_info       |  7   |    类或接口的符号引用    |
  |      CONSTANT_String_info       |  8   |     字符串类型字变量     |
  |     CONSTANT_Fieldref_info      |  9   |      字段的符号引用      |
  |     CONSTANT_Mehtodref_info     |  10  |      方法的符号引用      |
  | CONSTANT_IntefaceMehtodref_info |  11  |   接口中方法的符号引用   |
  |    CONSTANT_NameAndType_info    |  12  | 字段或方法的部分符号引用 |
  |   CONSTANT_MethodHandle_info    |  15  |       表示方法句柄       |
  |    CONSTANT_MethodType_info     |  16  |       表示方法类型       |
  |   CONSTANT_InvokeDynamic_info   |  18  |  表示一个动态方法调用点  |

  例如`CONSTANT_Class_info `的结构

  | 类型 |    名称    | 数量 |
  | :--: | :--------: | :--: |
  |  u1  |    tag     |  1   |
  |  u2  | name_index |  1   |

  * tag
    * 标志位
  * name_index
    * 索引值
      * 它指向常量池中一个`CONSTANT_Utf-8_info`类型常量，代表这个类（或接口）的全限定名，指向了常量池
