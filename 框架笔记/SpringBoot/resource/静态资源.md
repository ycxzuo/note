# 静态资源

## 读取

默认情况下，Spring Boot 使用 `ResourceHttpRequestHandle` 在 `classpath` 或者 `ServletContext` 根目录下的

* /static
* /public
* /resources
* META-INF/resources

目录中加载静态内容，其存储在 `org.springframework.boot.autoconfigure.web.WebProperties.Resources#staticLocations` 中，并在 `resourceProperties.getStaticLocations()` 中保存，加载到 `ResourceHandler` 中。静态资源可以利用自定义规则继承 `WebMvcConfigurerAdapter` 或者实现 `WebMvcConfigurer` 并重写 `addResourceHandlers` 方法来添加自己的静态资源路径，如果想覆盖之前 Spring Boot 的静态资源读取方式，可以继承 `WebMvcConfigurationSupport` 并自定义 `requestMappingHandlerMapping` 方法

其二者皆可以做到自定义加载静态资源的方式，但是前者安全性比较高，后者可能会造成一些其他组件的功能失效，例如 swagger

* `WebMvcConfigurerAdapter` 在 JDK 8 由于有 Interface 有 default 方法了，所以被废弃
* `WebMvcConfigurer` 在 `AbstractApplicationContext#refresh` 方法中的 `finishBeanFactoryInitialization` 方法去加载 `resourceHandlerMapping` 的 bean 时，会加载到 `WebMvcConfigurationSupport#resourceHandlerMapping` 方法，其又会调用 `DelegatingWebMvcConfiguration#addResourceHandlers` 方法，这个 configuration 加载的时候会自动注入所有被 `WebMvcConfigurer` 接口实现的实现类加载进来，此时就会调用到我们自定义的 `WebMvcConfigurer` 实现类的 `addResourceHandlers` 方法进行注册
* `WebMvcConfigurationSupport` 在 `WebMvcAutoConfiguration` 上有被修饰的注解 `@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)`，所以在我们继承了 `WebMvcConfigurationSupport` 并把它注册成一个 bean 时，`WebMvcAutoConfiguration` 就不会帮我们注册 Spring Boot 默认的静态资源路径了