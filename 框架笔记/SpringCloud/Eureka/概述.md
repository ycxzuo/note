# Spring Cloud Eureka

## 概述

Eureka-> 找到了，有了

基于 Netflix Eureka 的二次封装，由两部分组成

* Eureka Server 注册中心
* Eureka Client 服务注册

在 Spring Cloud 中担任服务注册和发现的任务，是重要的基础功能，它有**心跳监测，健康检查，负载均衡**等功能



## 服务中心

### 客户端发现

客户端在注册中心找到所有服务端的地址，然后根据某种负载均衡机制找到服务端

* 优点
  * 简单直接，不需要代理的介入
  * 知道所有的可用的服务器
* 缺点
  * 客户端得自己实现一套负载均衡算法

### 服务端发现

由代理去众多服务端中挑选出一个服务器地址，然后供客户端调用

* 优点
  * 服务端对于客户端不可见
* 缺点
  * 需要代理的介入



## Eureka Server

### 服务构建

#### 导入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

#### 启动main方法上加上`@EnableEurekaServer` 

#### 更改配置文件

```yml
# 项目名称
spring:
  application:
    name: eureka-server

# 注册中心端口配置
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
    # 关闭自己注册自己
    register-with-eureka: false
    #要不要去注册中心获取其他服务的地址,单点服务器无需拉取
    fetch-registry: false
  # 关闭安全监测（Eureka对于经常上下线的服务表示是上线状态，建议设ture默认）
  server:
    enable-self-preservation: true

# 服务启动端口
server:
  port: 8761
```

#### 启动项目



### 启动流程

从注解 `@EnableEurekaServer` 开始找起

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(EurekaServerMarkerConfiguration.class)
public @interface EnableEurekaServer {

}
```

查找 EurekaServerMarkerConfigrution 

```java
@Configuration(proxyBeanMethods = false)
public class EurekaServerMarkerConfiguration {

	@Bean
	public Marker eurekaServerMarkerBean() {
		return new Marker();
	}

	class Marker {

	}

}
```

查找 EurekaServerMarkerConfigrution.Marker  使用的地方

```java
@Configuration(proxyBeanMethods = false)
@Import(EurekaServerInitializerConfiguration.class)
@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)
@EnableConfigurationProperties({ EurekaDashboardProperties.class,
		InstanceRegistryProperties.class })
@PropertySource("classpath:/eureka/server.properties")
public class EurekaServerAutoConfiguration implements WebMvcConfigurer {
    ...
}
```

查看 EurekaServerInitializerConfiguration 

```java
@Configuration(proxyBeanMethods = false)
public class EurekaServerInitializerConfiguration
		implements ServletContextAware, SmartLifecycle, Ordered {
    	@Override
	public void start() {
		new Thread(() -> {
			try {
				// TODO: is this class even needed now?
				eurekaServerBootstrap.contextInitialized(
						EurekaServerInitializerConfiguration.this.servletContext);
				log.info("Started Eureka Server");

				publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()));
				EurekaServerInitializerConfiguration.this.running = true;
				publish(new EurekaServerStartedEvent(getEurekaServerConfig()));
			}
			catch (Exception ex) {
				// Help!
				log.error("Could not initialize Eureka servlet context", ex);
			}
		}).start();
	}
}
```

该方法会在 SpringBoot 自启动时调用 org.springframework.context.support.AbstractApplicationContext#finishRefresh 方法时调用，此时，Eureka Server 启动开始



### Eureka 高可用

使用 Eureka 集群，然后两两注册



## Eureka Client

### 服务构建

#### 导入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

#### 启动main方法上加上`@EnableDiscoveryClient` (非必须)

#### 更改配置文件

```yml
# 启动端口
server:
  port: 8081

# 服务名称
spring:
  application:
    name: eureka-client

# 注册中心地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
  # 点击Eureka页面的链接的IP值
  instance:
    hostname: clientName
```

#### 启动项目



### 启动流程

在依赖 spring-cloud-netflix-eureka-client 的 META-INF 文件夹下的 spring.factories 中有

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\
org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration,\
org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\
org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\
org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\
org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfiguration,\
org.springframework.cloud.netflix.eureka.loadbalancer.LoadBalancerEurekaAutoConfiguration

org.springframework.cloud.bootstrap.BootstrapConfiguration=\
org.springframework.cloud.netflix.eureka.config.EurekaConfigServerBootstrapConfiguration

```

在 EurekaClientAutoConfiguration 类中会初始化 org.springframework.cloud.netflix.eureka.CloudEurekaClient 

```java
@Bean(destroyMethod = "shutdown")
@ConditionalOnMissingBean(value = EurekaClient.class,
                          search = SearchStrategy.CURRENT)
@org.springframework.cloud.context.config.annotation.RefreshScope
    @Lazy
    public EurekaClient eurekaClient(ApplicationInfoManager manager,
                                     EurekaClientConfig config, EurekaInstanceConfig instance,
                                     @Autowired(required = false) HealthCheckHandler healthCheckHandler) {
    // If we use the proxy of the ApplicationInfoManager we could run into a
    // problem
    // when shutdown is called on the CloudEurekaClient where the
    // ApplicationInfoManager bean is
    // requested but wont be allowed because we are shutting down. To avoid this
    // we use the
    // object directly.
    ApplicationInfoManager appManager;
    if (AopUtils.isAopProxy(manager)) {
        appManager = ProxyUtils.getTargetObject(manager);
    }
    else {
        appManager = manager;
    }
    CloudEurekaClient cloudEurekaClient = new CloudEurekaClient(appManager,
                                                                config, this.optionalArgs, this.context);
    cloudEurekaClient.registerHealthCheck(healthCheckHandler);
    return cloudEurekaClient;
}
```

可以看见 Bean 的加载是采用的懒加载模式

```java
public class CloudEurekaClient extends DiscoveryClient {
    ...
}
```

初始化父类的时候，Eureka Client 的 Bean 就准备好了

在 org.springframework.cloud.netflix.eureka.serviceregistry.EurekaAutoServiceRegistration 类

```java
public class EurekaAutoServiceRegistration implements AutoServiceRegistration,
		SmartLifecycle, Ordered, SmartApplicationListener {
    ...
    @Override
	public void start() {
		// only set the port if the nonSecurePort or securePort is 0 and this.port != 0
		if (this.port.get() != 0) {
			if (this.registration.getNonSecurePort() == 0) {
				this.registration.setNonSecurePort(this.port.get());
			}

			if (this.registration.getSecurePort() == 0 && this.registration.isSecure()) {
				this.registration.setSecurePort(this.port.get());
			}
		}

		// only initialize if nonSecurePort is greater than 0 and it isn't already running
		// because of containerPortInitializer below
		if (!this.running.get() && this.registration.getNonSecurePort() > 0) {

			this.serviceRegistry.register(this.registration);

			this.context.publishEvent(new InstanceRegisteredEvent<>(this,
					this.registration.getInstanceConfig()));
			this.running.set(true);
		}
	}
}
```

在调用`org.springframework.cloud.netflix.eureka.serviceregistry.EurekaServiceRegistry#register`

```java
@Override
public void register(EurekaRegistration reg) {
    maybeInitializeClient(reg);

    if (log.isInfoEnabled()) {
        log.info("Registering application "
                 + reg.getApplicationInfoManager().getInfo().getAppName()
                 + " with eureka with status "
                 + reg.getInstanceConfig().getInitialStatus());
    }

    reg.getApplicationInfoManager()
        .setInstanceStatus(reg.getInstanceConfig().getInitialStatus());

    reg.getHealthCheckHandler().ifAvailable(healthCheckHandler -> reg
                                            .getEurekaClient().registerHealthCheck(healthCheckHandler));
}
```

在 maybeInitializeClient(reg); 方法中会初始化 

```java
private void maybeInitializeClient(EurekaRegistration reg) {
   // force initialization of possibly scoped proxies
   reg.getApplicationInfoManager().getInfo();
   reg.getEurekaClient().getApplications();
}
```

```java
public CloudEurekaClient getEurekaClient() {
   if (this.cloudEurekaClient.get() == null) {
      try {
         this.cloudEurekaClient.compareAndSet(null,
               getTargetObject(eurekaClient, CloudEurekaClient.class));
      }
      catch (Exception e) {
         log.error("error getting CloudEurekaClient", e);
      }
   }
   return this.cloudEurekaClient.get();
}
```

