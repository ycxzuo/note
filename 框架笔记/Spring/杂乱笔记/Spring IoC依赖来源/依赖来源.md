# 依赖来源

## 依赖查找的来源

| 来源           | 配置元数据                     |
| -------------- | ------------------------------ |
| BeanDefinition | <bean id="user" class="..." /> |
|                | @Bean                          |
|                | BeanDefinitionBuilder          |
| 单例对象       | API 实现                       |



## 依赖注入的来源

| 来源                   | 配置元数据                     |
| ---------------------- | ------------------------------ |
| BeanDefinition         | <bean id="user" class="..." /> |
|                        | @Bean                          |
|                        | BeanDefinitionBuilder          |
| 单例对象               | API 实现                       |
| 非 Spring 容器管理对象 |                                |

依赖注入比依赖查找就是多出了非 Spring 容器管理对象这一个，其体现在

`AbstractApplicationContext#prepareBeanFactory`

```java
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
beanFactory.registerResolvableDependency(ResourceLoader.class, this);
beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
beanFactory.registerResolvableDependency(ApplicationContext.class, this);
```



## Spring BeanDefinition 作为依赖来源

* 要素
  * 元数据：`BeanDefinition`
  * 注册：`BeanDefinitionRegistry#registerBeanDefinition`
  * 类型：延迟和非延迟
  * 顺序：Bean 生命周期顺序按照注册顺序

### 注意

`BeanDefinitionRegistry` 注册中心默认使用  `DefaultListableBeanFactory`

其中 `beanDefinitionMap` 字段存储的是 BeanDefinition 的名称和 BeanDefinition 对象，但是由于其是 `ConcureentHashMap`，线程安全但是无序，所以有一个字段是 `ArrayList` 类型的 `beanDefinitionNames`，保存了 BeanDefinition 的顺序

 

## 单例对象作为依赖来源

* 要素
  * 来源：外部普通 Java 对象
  * 注册：`SingletonBeanRegistry#registerSingleton`
* 限制
  * 无生命周期管理
  * 无法实现延迟初始化 Bean

### 注意

* `SingletonBeanRegistry` 是 `DefaultListableBeanFactory` 的父类
* 其中 `singletonObjects` 字段存储的是 singleton 的名称和 singleton 对象，但是由于其是 `ConcureentHashMap`，线程安全但是无序，所以有一个字段是 `LinkedHashSet` 类型的 `registeredSingletons`，保存了 singleton 的顺序
* 在 `DefaultListableBeanFactory#getBean(String)` 的时候，会调用 `AbstractBeanFactory#doGetBean`，这里会先去 singleton 里面查找，如果找到了就返回，没找到才会在 `BeanDefinition` 中去找到 Bean 的元信息，再初始化 Bean，并激活 Bean 的生命周期



## 非 Spring 容器管理对象作为依赖来源

* 要素
  * 注册：`ConfigurableListableBeanFactory#registerResolvableDependency`
* 限制
  * 无生命周期管理
  * 无法实现延迟初始化 Bean
  * 无法通过依赖查找

### 注意

* 该操作需要在初始化 Bean 之前注入，所以可以使用两个方式做到
  *  `ConfigurableApplicationContext#addBeanFactoryPostProcessor` 来注册这个 `ResolvableDependency`
  * `ConfigurableApplicationContext#getBeanFactory` 获取 `BeanFactory` 直接注册
* 该方式只能用于类型去注入，因为没有地方给名称注入



## 外部化配置作为依赖来源

* 要素
  * 类型：非常规 Spring 对象依赖来源
* 限制
  * 无生命周期管理
  * 无法实现延迟初始化 Bean
  * 无法通过依赖查找

`ContextAnnotationAutowireCandidateResolver` 中保存着两种注解的实现

* `@Qualifier`
* `@Value`

`EmbeddedValueResolverAware` 回调生成 `StringValueResolver`

`DefaultListableBeanFactory#doResolveDependency` 中 

```java
...
// 获取注解上的占位符
Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
if (value != null) {
    if (value instanceof String) {
        // 获取解析后的值
        String strVal = resolveEmbeddedValue((String) value);
        BeanDefinition bd = (beanName != null && containsBean(beanName) ?
                             getMergedBeanDefinition(beanName) : null);
        value = evaluateBeanDefinitionString(strVal, bd);
    }
    TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
    try {
        return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
    }
    catch (UnsupportedOperationException ex) {
        // A custom TypeConverter which does not support TypeDescriptor resolution...
        return (descriptor.getField() != null ?
                converter.convertIfNecessary(value, type, descriptor.getField()) :
                converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
    }
}
...
```



## @Bean 的处理流程是怎样的

* 解析范围：Configuration Class 中的 @Bean 方法
* 方法类型：静态 @Bean 方法和实例 @Bean 方法



## 注意

* Spring IoC 容器启动后可以注册单例对象而不引起任何影响
* Spring IoC 容器启动后可以注册 `BeanDefinition`，但是会将之前容器启动时调用 `DefaultListableBeanFactory#freezeConfiguration` 方法（将字段 configurationFrozen 标识置为 true，将字段 beanDefinitionNames 列表中的 Bean Names 放入字段 frozenBeanDefinitionNames 数组中）的保险取消，导致字段 frozenBeanDefinitionNames 被设置为 null，所以不建议在 Spring IoC 容器启动后注册 `BeanDefinition`

