# 依赖注入

## 依赖注入的模式

### 手动模式

配置或者编程的方式，提前安排注入规则

* XML 资源配置元信息
* Java 注解配置元信息
* API 配置元信息



### 自动模式

实现方提供依赖自动关联的方式，按照内建的注入规则

* Autowiring  （自动绑定）



## 依赖注入的类型

| 依赖注入类型 | 配置元信息举例                                |
| ------------ | --------------------------------------------- |
| Setter 方法  | <property name="user" ref="userBean"/>        |
| 构造器       | <constructor-arg name="user" ref="userBean">  |
| 字段         | @Autowired User user;                         |
| 方法         | @Autowired public void user(User user){...}   |
| 接口回调     | class MyBean implements BeanFactoryAware{...} |



## 自动绑定 Autowiring modes

枚举参考：`org.springframework.beans.factory.annotation.Autowire`

| 模式        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| no          | 默认值，未激活 Autowiring，需要手动指定依赖注入对象          |
| byName      | 根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性 |
| byType      | 根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性 |
| constructor | 特殊 byType 类型，用于构造器参数                             |



## Bean 注入

### Setter 方法注入

#### 手动模式

* XML 资源配置元信息
* Java 注解配置元信息
* API 配置元信息



#### 自动模式

* Autowiring  （自动绑定）
  * byName
  * byType



### 构造器注入

#### 手动模式

* XML 资源配置元信息
* Java 注解配置元信息
* API 配置元信息



#### 自动模式

* Autowiring  （自动绑定）
  * constuctor



### 字段注入

#### 手动模式

* Java 注解配置元信息
  * `@Autowired`（默认 byType，不支持 static 修饰的字段）
    * static 字段处理方式：通常通过实例方法注入，然后再通过该方法注入到静态资源，还有一种比较常见，通过 ApplicationContextAware 或 BeanFactoryAware 来操作
  * `@Resource`（默认 byName，不支持 static 修饰的字段）
  * `@Inject`(可选)



### 方法注入

#### 手动模式

Java 注解配置元信息

* `@Autowired`（默认 byType，不支持 static 修饰的字段）
  * static 字段处理方式：通常通过实例方法注入，然后再通过该方法注入到静态资源，还有一种比较常见，通过 `ApplicationContextAware` 或 `BeanFactoryAware` 来操作
* `@Resource`（默认 byName，不支持 static 修饰的字段），**方法调用的时机比 `@Autowired` 早**
* `@Inject`(可选)
* `@Bean`



### 接口回调注入

* Aware 系列接口回调，实现接口就可以拿到内建 Bean 的实例

  * 自动模式

  | 内建接口                       | 说明                                             |
  | ------------------------------ | ------------------------------------------------ |
  | BeanFactoryAware               | 获取当前 IoC 容器 - BeanFactory                  |
  | ApplicationContextAware        | 获取 Spring 应用上下文 - ApplicationContext      |
  | EnvironmentAware               | 获取 Environment                                 |
  | ResourceLoaderAware            | 获取资源加载器 - ResourceLoader                  |
  | BeanClassLoaderAware           | 获取家在当前 Bean Class 的 ClassLoader           |
  | BeanNameAware                  | 获取当前 Bean 名称                               |
  | MessageSourceAware             | 获取 MessageSource，用于国际化                   |
  | ApplicationEventPublisherAware | 获取 ApplicationEventPublisher，用于 Spring 事件 |
  | EmbeddedValueResolverAware     | 获取 SpringValueResolver，用于占位符处理         |



### 基础类型注入

* 原生类型：boolean, byte, char, short, long, int, float, double
* 标量类型：Number, Character, Boolean, Enum, Locale, Charset, Currency, Properties, UUID
* 常规类型：Object, String, TimeZone, Calendar, Optional 等
* Spring 类型：Resource, InputSource, Formatter 等



### 集合类型注入

* 数组类型：原生类型，标量类型，常规类型，Spring 类型
* 集合类型
  * Collection：List, Set(SortedSet, NavigableSet, EnumSet)
  * Map：Properties



### 限定注入

* 使用注解 `@Qualifier` 限定
  * 通过 Bean 名称限定
  * 通过分组限定
* 基于注解 `@Qualifier` 扩展限定
  * 自定义注解 - 如 Spring Cloud 的 `@LoadBalanced` 注解



### 延迟依赖注入

* 使用 API `ObjectFactory` 延迟注入
  * 单一类型
  * 集合类型
* 使用 API `ObjectProvider` 延迟注入（推荐使用）
  * 单一类型
  * 集合类型



## 依赖注入类型选择

* 注入选型
  * 低依赖：构造器注入
  * 多依赖：Setter 注入
  * 便利性：字段注入
  * 声明类：方法注入



## 依赖处理过程

处理判断注入类型

* 入口：`DefaultListableBeanFactory#resolveDependency`
* 依赖描述符：`DependencyDescriptor`
  * 该对象在 `AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject` 方法中创建，存入了需要 `@Autowired` 字段注入的字段类型和是否必须标识
* 自定义绑定候选对象处理器：`AutowireCandidateResolver`

流程，其核心是 **`DefaultListableBeanFactory#resolveMultipleBeans`** 和 **`DefaultListableBeanFactory#findAutowireCandidates`** 两个方法

`org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency` 有 4 个分支

* 是 `Optional` 类型
  * 将 `doResolveDependency` 方法解析的类型数据放入 `Optional` 中并返回
* 是 `ObjectFactory` 或者 `ObjectProvider` 类型
  * 先返回 `DependencyObjectProvider` 类型，在调用 `getObject` 方法时再调用 `doResolveDependency `方法返回数据实现延迟加载
* 是 `javax.inject.Provider` 类型
  * 返回 `Jsr330Factory().createDependencyProvider` 创建出的数据
* 其他类型
  * 调用 `ContextAnnotationAutowireCandidateResolver#getLazyResolutionProxyIfNecessary` 方法判断对象是否被 @Lazy 注解标注
    * 是 -> 返回 `buildLazyResolutionProxy(descriptor, beanName)` 延迟加载包装类，并返回最终结果
    * 否 -> 返回 null
      * 调用 `doResolveDependency` 方法解析的类型数据并返回

`org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency`

* 调用 `descriptor.getDependencyType()` 方法获取类型
* 调用 `resolveMultipleBeans` 方法，此处又有 4 个分支
  * 是 `StreamDependencyDescriptor` 类型
    * 调用 `findAutowireCandidates` 方法获取与前面获取类型匹配的类型
      * 调用 `BeanFactoryUtils.beanNamesForTypeIncludingAncestors` 方法获取所有匹配传入类型（requiredType）的 Bean 名称
        * 调用 `lbf.getBeanNamesForType` 获取对应类型匹配的 Bean 名称数组
          * 从缓存中拿出类型对应的被解析的 Bean 名称数组
            * 如果缓存不存在：执行 `doGetBeanNamesForType` 获取并将值存入缓存中
            * 如果存在直接返回
        * 如果是 `ListableBeanFactory` 同时还是 `HierarchicalBeanFactory`，那么递归查找
      * 判断如果是以下 4 种类型就直接拿到其实例放入结果集内
        * `ApplicationEventPublisher`
        * `ResourceLoader`
        * `BeanFactory`
        * `ApplicationContext`
      * 遍历上面调用方法查到的 Bean 名称数组，遍历执行 `isSelfReference` 和 `isAutowireCandidate`
        * 判断不是自引用，候选对象不是指向原始 Bean 且不是 Bean 的工厂方法
        * 判断是自动注入候选对象
        * 上面两条成立，调用 `addCandidateEntry` 方法，利用 `descriptor.resolveCandidate` 方法（底层调用 `beanFactory.getBean(beanName)`）将 Bean 放入候选值 Map 中
    * 遍历查找出来的数据的 bean 类型并调用 `descriptor.resolveCandidate` 方法（底层调用 `beanFactory.getBean(beanName)`）获取解析出来的 Bean 并放入 Stream 流
    * 判断 Bean 是否被需要根据 Orderd 排序
  * 是数组类型
    * 调用 `descriptor.getResolvableType()` 方法获取能解析的类型
    * 判断传入类型是否能被解析
      * 不能 -> 返回 null
      * 能 -> 调用 `findAutowireCandidates` 方法获取与前面获取类型匹配的类型
      * 进行必要的类型转换或者排序
        * `converter.convertIfNecessary(matchingBeans.values(), type)` 将匹配的值注入到 Bean 中
  * 是集合类型
    * 调用 `descriptor.getResolvableType().asCollection().resolveGeneric()` 方法获取集合的泛型
    * 调用 `findAutowireCandidates` 方法获取与前面获取类型匹配的类型
    * 进行必要的类型转换或者排序
  * 是 `Map`  类型
    * 调用 `findAutowireCandidates` 方法获取 Map
      * 其 Bean 的名称作为 Map 的 Key 值，Bean 作为 Value 放入 Map 返回
* 判断类型是不是集合类型
  * 是 -> 返回刚刚查到的数据
  * 否 -> 
    * 调用 `findAutowireCandidates` 方法获取 Map
    * 在 Map 中找到 primary Bean，如果有多个就报错
    * 调用 `descriptor.resolveCandidate`



## @Autowired 注入

`org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor`

```java
	private int order = Ordered.LOWEST_PRECEDENCE - 2; // 优先级
```

* 注入过程
  * 元信息解析：`DependencyDescriptor`
  * 依赖查找
  * 依赖注入（字段、方法）

`AbstractAutowireCapableBeanFactory`:

* `createBean`：创建 Bean
  * `doCreateBean`：执行创建 Bean
    * `applyMergedBeanDefinitionPostProcessors`：合并 `BeanDefinition` 处理
      * `AutowiredAnnotationBeanPostProcessor`: 
      * `postProcessMergedBeanDefinition`：合并 `BeanDefinition` 处理
        * `findAutowiringMetadata`：从缓存中寻找注入的元信息，如果没有就执行下面的方法构建
          * `buildAutowiringMetadata`：构建注入的元信息（找被`@Autowired` 和 `@Value` 注解标注的字段，从这个类一直往父类，直至找到 `Object` 类。这些注解存在 `autowiredAnnotationTypes` 的 Set 属性中）
        * `InjectionMetadata`：
        * `checkConfigMembers`：
    * `populateBean`：填充 Bean 信息
      * `postProcessProperties` 再次调用 `findAutowiringMetadata` 找到注入信息，并开始注入
        * `AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement`
        * `inject`：调用依赖处理过程（上面分析过）的方法拿到解析的结果值，然后利用反射（如果是私有的，调用暴力破解）将值注入给字段（`field.set(bean, value)`）



## Java 通用注解注入原理

`CommonAnnotationBeanPostProcessor`

```java
	public CommonAnnotationBeanPostProcessor() {
		setOrder(Ordered.LOWEST_PRECEDENCE - 3); // 优先级比 @Autowired 高，先处理
		setInitAnnotationType(PostConstruct.class);
		setDestroyAnnotationType(PreDestroy.class);
		ignoreResourceType("javax.xml.ws.WebServiceContext");
	}
```

* 注入注解
  * `javax.xml.ws.WebServiceRef`
  * `javax.ejb.EJB`
  * `javax.annotation.Resource`
* 生命周期注解 -> 主要是 `InitDestroyAnnotationBeanPostProcessor` 提供能力
  * `javax.annotation.PostConstruct`
  * `javax.annotation.PreDestroy`

如果是有父子层级的初始化方法，会先执行父类的，再执行子类的，原因是 `CommonAnnotationBeanPostProcessor` 的 `buildResourceMetadata` 最后是执行的 `elements.addAll(0, currElements);`



## 自定义依赖注入注解

* 基于 AutowiredAnnotationBeanPostProcessor 实现
* 自定义实现
  * 生命周期处理
    * InstantiationAwareBeanPostProcessor
    * MergedBeanDefinitionPostProcessor
  * 元数据
    * InjectedElement
    * InjectionMetadata

**一定要注入 Bean 的注入顺序问题， static 修饰可以导致某些 Bean 注入而不用导致所在 Bean 被提前初始化**