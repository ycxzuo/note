# Java内存区域和内存溢出异常

## 运行时数据区域

* 程序计数器(线程私有)
* 虚拟机栈(线程私有)
* 本地方法栈(线程私有)
* 堆(线程共享)
* 方法区(线程共享)

### 程序计数器

* 定义
  * 一块内存较小的空间,可以看作是当前线程所执行的字节码行号指示器,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.可以保证线程切换后能恢复到正确的执行位置.
* 特点
  * 每个线程都有自己独立的程序计数器(线程私有)
  * 在运行native方法时,计数器值为空(undefined)
  * 唯一一个没有OOM情况的区域

### java虚拟机栈

* 定义

  * 描述java方法执行的内存模型,每个方法在执行的时候都会创建一个栈桢,每个方法从调用直到执行完成,对应的栈桢在虚拟机栈中入栈到出栈.

* 特点

  * 每个线程都有自己独立的程序计数器(线程私有)
  * 生命周期与线程相同
  * 线程请求的栈深度大于虚拟机允许的深度,将抛出StackOverflowError
  * 虚拟机栈动态扩展时申请不到足够的内存,将会抛出OOM.

* 结构

  * 局部变量表(所谓的栈)

  * 栈桢

  * 动态链接

  * 方法出口

    ...

### 本地方法栈

* 定义
  * 与虚拟机栈作用相类似,只不过虚拟机栈为执行java方法服务,而本地方法栈为虚拟机使用的native方法服务,虚拟机对本地方法使用的语言,使用方式和数据结构没有强制规定,虚拟机可以自由实现它.HotShot直接把本地方法栈和虚拟机栈合二为一.
* 特点
  * 与虚拟机栈一样

### java堆

* 定义
  * 虚拟机管理的最大一块内存,在虚拟机启动时创建,存在的唯一目的就是存放对象
* 特点
  * 线程共享,但是也会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)
  * 随着JIT编译器的发展和逃逸分析技术逐渐成熟.栈上分配,标量替换优化技术将会导致一些微妙的变化产生,所有的对象都分配在堆上也渐渐变得不是那么'绝对'了
  * 垃圾收集器管理的主要区域,可以细分为新生代,老年代.再细致一点就是Eden空间,From Survivor空间和 To Surviver空间.
  * 堆可以处于物理上不连续的内存空间中,只要逻辑上连续就可以
  * 堆可以自动扩展,当堆无法再扩展时,就会抛出OOM

### 方法区(Non-Heap)

* 定义
  * 又被称为永久带,用于储存已被虚拟机加载的类信息,常量,静态变量和已被编译的代码等数据
* 特点
  * HotShot把GC区域扩展至方法区,省去了为方法区编写GC方法,1.7的JDK已经把字符串常量池移出永久带.
  * 被GC的机会很少,主要是针对常量池的回收和类型的卸载.但是这个区域的垃圾回收很难令人满意,尤其是类型的卸载
  * 当方法区无法满足分配要求时,将抛出OOM.

### 运行时常量池

* 定义
  * 方法区的一部分,用于存放编译期生成的各种字面量和符号引用,还会把翻译出来的直接引用也存储与运行时常量池
* 特点
  * 具备动态性,运行期间也可以将新的常量放入池中(例如String.intern())
  * 方法区一部分,也会在相同情况下抛出OOM

### 直接内存

* 定义
  * JDK1.4中引入的NIO类,引入了通道与缓冲区的I/O方式,他可以使用Native函数库直接分配堆外内存,然后通过java堆中的DirectByteBuffer对象作为这块内存的引用进行操作,避免了Java堆和Native堆中来回复制数据.
* 特点
  * 不会受到Java堆配置的内存大小限制,但是会受到本机内存(包括RAM一级SWAP区或者分页文件)的限制及处理器寻址空间的限制.
  * 动态扩展时可能会出现OOM



## HotShot虚拟机对象探秘

### 对象的创建



