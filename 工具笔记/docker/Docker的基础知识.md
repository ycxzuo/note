# Docker 的基础知识

> 内容均摘自 极客时间

## 核心技术

* Cgroups 技术
* Namespace 技术
  * PID Namespace 
  * Mount Namespace 
    * 它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。
  * UTS Namespace 
  * IPC Namespace 
  * Network Namespace 
  * User Namespace 



### Cgroups（Linux Control Group）

#### 概念

Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等





### Namespace

#### 概念

Namespace 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容

#### 缺陷

* 容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核
* 在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间



### rootfs

#### 概念

这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）

rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。

#### 改善问题

由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性

由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。

#### 缺陷

一旦你的同事们修改了这个 rootfs，新旧两个 rootfs 之间就没有任何关系了。这样做的结果就是极度的碎片化。我们能不能以增量的方式去做这些修改呢？

*Docker 优化*

Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。这个想法不是凭空臆造出来的，而是用到了一种叫作**联合文件系统（Union File System）**的能力

#### 组成

以一个 ubuntu:latest 的镜像来说

* 只读层
  * 对应的正是 ubuntu:latest 镜像的五层，在容器最底层
* 可读写层
  * 容器的 rootfs 最上面的一层，在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来，在容器最上层
* Init 层
  * 它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息



上面的读写层通常也称为容器层，下面的只读层称为镜像层，所有的增删查改操作都只会作用在容器层，相同的文件上层会覆盖掉下层。知道这一点，就不难理解镜像文件的修改，比如修改一个文件的时候，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write

> 重新挂载/tmp目录的实验执行完成后，在宿主机上居然可以看到这个挂载信息。实际上，大家自己装的虚拟机，或者云上的虚拟机的根目录，很多都是以share方式的挂载的。这时候，你在容器里做mount也会继承share方式。这样就会把容器内挂载传播到宿主机上。解决这个问题，你可以在重新挂载/tmp之前，在容器内先执行一句：mount(“”, “/“, NULL, MS_PRIVATE, “”) 这样，容器内的根目录就是private挂载的了