# MySQL 的结构

MySQL 可以分为两个部分

* Service 层
* 存储引擎层



## Service 层

涵盖 MySQL 的大多数核心服务功能以及内置函数，所有跨存储引擎的功能也都在这一层，比如存储过程，触发器，视图等

* 连接器
* 查询缓存
* 分析器
* 优化器
* 执行器

### 连接器

操作 MySQL 首先就要连接到数据库上， 这时候就会连上连接器，连接器负责跟客户端建立连接，获取权限，维持和管理连接

```mysql
mysql -h localhost -P3306  -uroot -p
```

然后输入密码就可以连接上数据库了

连接命令中 mysql 是客户端工具，用来跟服务器建立连接，在完成经典的 TCP 握手后，连接器就开始认证身份，这个时候用的就是你输入的用户名和密码

* 验证失败，会收到 `Access denied for user` 的报错信息
* 验证成功，连接器会到权限表里面查出你拥有的权限，之后这个链接里面的权限都会读取这个权限

连接完成后，如果没有后续动作，这个连接就处于空闲状态，客户端如果太长时间没有动作，连接器就会自动断开，默认时间是 8 小时，可以使用命令查看 `wait_timeout` 参数

```mysql
show variables like '%timeout%';
```

可以在 my.ini 中修改

超时后客户端再次发送请求会收到一个错误提示：`Lost connection to MySQL server during query` 

数据库的连接有两种

* 长连接
* 短连接

建立连接的过程通常是比较复杂的，所以我建议你在使用中尽量减少建立连接的动作，也就是尽量使用长连接。但是连接过多会导致内存增长，连接断开后才会释放内存，如果内存占用过大，会导致 OOM，使得 MySQL 重启

*解决方案*

1. 定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后断开连接，之后要查询时重连
2. 在执行一次较大操作后，在语句后面 `mysql_reset_connection` 来重新初始化连接资源，与 `mysql_change_user` 区别是，前者是轻量级的，后者适用于更改了权限之类的操作后重置权限。这个过程不会重连和重新权限校验，但是会将连接恢复到刚创建状态



### 查询缓存

建立连接后，执行 select 语句，就会到第二步：查询缓存，*MySQL 8 之后就删除了这个功能*

MySQL 拿到一个请求后，会先到查询缓存看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式存在内存中，其 key 值是 SQL 语句的 hash 值，如果查询能够直接在缓存中查到，就会直接把 value 返回

**但是不建议开启查询缓存**

查询缓存经常失效，只要有对一个表的更新，这个表上所有的查询缓存都会被清空，只有系统配置表等很长时间才会更新一次的表才会有开启缓存的意义

```mysql
show variables like '%query_cache%';
```

可以看到是否开启缓存

query_cache_type=0 时表示关闭，1 时表示打开，SQL_NO_CACHE 禁用查询缓存 ，2 表示只要 select  中明确指定 SQL_CACHE 才缓存。**这个操作建议在 mysql 关闭的情况下使用，因为在缓存开启的时候，关闭不完全；在关闭的时候打开会报错**，报错信息 `1651 - Query cache is disabled; restart the server with query_cache_type=1 to enable it`

```mysql
set @global.query_cache_type=1;
```



### 分析器

如果没有命中缓存，就要开始真正执行语句了，分析器用来对 SQL 语句进行解析

分析器会先做词法分析，输入的字符串和空格组层的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么，例如会从 `select` 关键字识别是一个查询语句

做完了词法识别之后，就要做语法分析，根据词法分析的结果，语法分析会根据语法规则判断这个 SQL 语句是否满足 MySQL 语法

语法错误识别出来后会提示出现错误的位置，要关注紧接着 “use near” 的内容



### 优化器

通过分析器后，MySQL 就知道要做什么，在开始执行之前，还会经过优化器处理

优化器是在表里面有多个索引的时候决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接数据。比如你执行下面这样的语句

```mysql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

* 既可以先从表 t1 里面取出 c = 10 记录 ID 的值，再根据 ID 值关联到表 t2，在判断 t2 里面 d 的值是否等于 20
* 也可以先从表 t2 里面取出 d = 20 记录 ID 的值，再根据 ID 值关联到表 t1，在判断 t1 里面 c 的值是否等于 10

优化器会根据执行效率决定使用哪一种方案



### 执行器

MySQL 通过优化器知道了该怎么做，于是就进入了执行器阶段

开始执行的时候要先判断一下对这个操作表有没有权限，因为 SQL 语句要操作的表不一定只是 SQL 语句表面上的，比如有触发器，得在执行器阶段才能确定，如果没有权限，就会返回没有权限的错误（如果命中缓存，会在返回结果的时候做权限验证），报错信息 `ERROR 1142 (42000): SELECT command denied to user 'root'@'localhost' for table 'T'`

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口

例如

```mysql
select * from T where ID=10;
```

T 表中没有索引，执行器执行过程是

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中
2. 调用引擎接口取 “下一行”，重复相同的逻辑，直到表的最后一行
3. 将满足条件的行组成的记录集作为结果集返回给客户端



## 存储引擎层

负责数据的存储和提取，是拔插模式的，支持 InnoDB，MySAM，Memory 等多个存储引擎