# 概念原理

## 索引

### _index

 指向一个或多个物理分片的逻辑命名空间

### _type

用于区分同一个集合的不同细分，在不同的细分中，数据的整体模式是相同或相似的，不适合完全不同的数据。多个 _type 可以在相同的索引中存在，只要他们字段不冲突即可，

### _id

文档标记符由系统自动生成或使用者提供

在实际应用中，数据模型不同，有不同 _type 需求的时候，我们应该建立单独地索引，而不是在一个索引下使用不同的 _type。删除过期数据时最好以索引为单位，而不是 _type 和 _id。在 ES 6.x 版本中，一个索引只允许一个 _type，未来的 7.x 将完全删除 _type 的概念



## 分片

在分布式系统中，单机无法存储规模巨大的数据，水平扩容增加机器来提高扩展能力，因此，需要把数据分成若干小块分配到各个机器上，然后通过某种策略找到某个数据块所在的位置

在分布式系统中，会把数据复制成多个副本，放置到不同的机器中，增加系统的可用性，同时数据副本还可以使度操作并发执行，分担集群压力。但多副本带来的问题是数据一致性

ES 将数据副本分成主从两份，主分片和副分片，恢复阶段以主分片为准

分片是底层的基本读写单元，分片的目的是分割巨大索引，让读写可以并行操作，分片是数据的容器，文档保存在分片内，不会跨分片存储。分片又被分配到集群内的各个节点里。当集群规模扩大或缩小时，ES 会自动在各节点中迁移分片，使数据仍然均匀分布在集群

一个 ES 索引包含很多分片，一个分片是一个 Lucene 的索引，它本生就是一个完整的搜索引擎，可以独立执行建立索引和搜索任务。Lucene 索引又由很多分段组成，每个分段都是一个倒排索引。ES 每次 “refresh” 都会生成一个新的分段，其中包含若干文档的数据。在每个分段内部，文档的不同字段被单独建立索引。每个字段的值由若干词（Term）组成，Term 是原文本内容经过分词器处理和语言处理后的最终结果（例如，去除标点符号和转换为词根）

索引建立的时候需要确定好分片数，在 5.x 之前，主分片数不可以修改，副分片书可以随时修改。现在，ES 已经支持在一定条件的限制下，对某个索引的主分片进行拆分（Split）或缩小（Shrink）。但是，我们仍然需要一开始就尽量规划好主分片数量：

* 先依据硬件情况定好单个分片容量
* 然后依据业务场景预估数据量和增长量
* 再除以单个分片容量

分片不够可以利用新建索引，搜索一个有 50 个分片的索引与搜索 50 个每个都有一个分片的索引完全等价，或者使用 _split API 来拆分索引（6.1版本支持）

应用中，我们不应该向单个索引持续写数据，直到它的分片巨大无比。巨大的索引会在数据老化后难以删除，以 _id 为单位删除文档不会立刻释放空间，删除的 doc 只在 Lucene 分段合并是才会真正从磁盘删除。建议周期性创建新索引，例如每天创建一个，然后用日期做后缀，用索引别名来关联



## 动态更新索引

通过关键词检索文档内容，会使用倒排索引的数据结构。**倒排索引一旦被写入文件后就具有不变性，所以文件访问不需要加锁**。读取时可以被文件系统缓存

索引如何更新，让新添加的文档可以被搜索到？

使用更多的索引，新增内容并写到一个新的倒排索引中，查询时，每个倒排索引都被轮流查询，查询完再对结果进行合并

**每次内存缓冲的数据被写入文件时，会产生一个新的 Lucene 段，每个段都是一个倒排索引**，在一个记录元信息的文件中描述了当前 Lucene 索引都含有哪些分段

由于分段的不可变性，更新、删除等操作实际上是将数据标记为删除，记录到单独的位置，这种方式称为标记删除。因此**删除部分数据不会释放磁盘空间**



## 数据写入

在写操作中，一般先在内存中缓冲一段数据，在将数据刷入磁盘。除了（direct方式），通过操作系统 write 接口写裁判数据，先会保存在缓存中，即使接口调用成功返回，数据也没有刷到磁盘，需要调用 flush或者等待操作系统的写入策略将缓存刷入磁盘，提高写入效率

ES 也是使用这种策略，每秒产生一个新分段，新段先写入文件系统缓存，稍后执行 flush 刷盘操作，写操作很快会执行完，一旦写成功，就可以直接打开读取了

带来的问题就是意外情况发生，会存在数据丢失风险。通用的做法是记录日志，如 mysql



## 段合并

在 ES 中，每秒清空一次写缓存，将这些数据写入文件，这个过程称为 refresh，每次 refresh 会创建一个新的 Lucene 段，但是分段数量太多会造成较大麻烦，每个段都会消耗文件句柄、内存。每个搜索请求都需要轮流检查每个段，查询完再对结果合并。所以段越多，搜索就会越慢。ES 需要通过一定的策略将这些较小的短合并成大的段，当合并结束后，旧的分段被删除，标记删除的数据才从磁盘删除

