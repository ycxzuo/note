# 类加载过程

## 加载

`加载`是`类加载(Class Loading)`过程的一个阶段，在`加载阶段`，虚拟机需要完成以下 3 件事

* 通过一个类的全限定名来获取定义此类的二进制字节流
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

虚拟机规范的这 3 点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如`通过一个类的全限定名来获取定义此类的二进制字节流`这条，没有明确指明二进制字节流要从哪里获取、怎样获取。许多举足轻重的 Java 技术都建立在这一基础之上，例如：

* 从`.ZIP`包中读取，这很常见，最终成为日后的`JAR`/ `EAR`/ `WAR`格式的基础
* 从网络中获取，这种场景最典型的应用就是`Applet`
* 运行时计算生成，这种场景使用得最多的就是动态代理技术，在`java.lang.reflect.Proxy`中，就是用了`ProxyGenerator.generateProxyClass`来为特定接口生成形式为`*$Proxy`的代理类的二进制字节流
* 由其他文件生成，典型场景是`JSP`应用，即由`JSP`文件声称对应的 Class 类
* 从数据库中读取，这种场景相对少见些，例如有些中间服务器（如`SAP Netweaver`）可以选择把程序安装到数据库中来完成程序代码在集群间的分发

相对于类加载过程的其他阶段，**一个*非数组类*的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的**，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的`loadClass()`方法）

对于数组类而言，情况就有所不同了，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为 C）创建过程就遵循以下规则

* **如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，一个类必须与类加载器一起确定唯一性）**
* **如果数组的组件类型不是引用类型（例如`int[]`数组），Java 虚拟机将会把数组 C 标记为与引导类加载器关联**
* **数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为`public`**

加载阶段完成后，**虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中**，方法区中的数据储存格式由虚拟机实现自行定义，虚拟机规范未定义此区域的具体数据结构。然后在内存中实例化一个`java.lang.Class`**类的对象**（并没有明确规定是在 Java 堆中，对于`HotSpot`虚拟机而言，**Class 对象比较特殊，它虽然是对象，但是存放在方法区里面**）

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是**交叉进行**的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在接在阶段之中进行的动作，仍然属于连接阶段的内容，**这两个阶段的开始时间仍然保持这固定的先后顺序**



## 验证

验证是连接阶段的第一步，这一阶段的日子是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

Java 语言本身是相对安全的语言（依然是针对 C/C++ 来说），使用纯粹的 Java 代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但是 **Class 文件并不一定要求用 Java 源码编译而来，可以使用任何途径产生，在字节码语言层面上，上述 Java 代码无法做到的事情都是可以实现的，至少语义可以表达出来**。虚拟机如果不检查输入的字节流，对其完全信任的话，**很可能因为载入了有害的字节流二导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作**

验证阶段是非常重要的，这个阶段是否严谨，直接决定了 Java 虚拟机是否能够承受恶意代码攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。验证阶段大致上会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证

### 文件格式验证

第一阶段要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

* 是否以魔数`0xCAFEBABE`开头
* 主、次版本号是否在当前虚拟机处理范围之内
* 常量池的常量是否有不被支持的常量类型（检查常量`tag`标志）
* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
* `CONSTANT_Utf8_info`型的常量中是否有不符合`UTF-8`编码的数据
* Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息

......

实际上，第一阶段的验证点远不止这些，上面这些只是从`HotSpot`虚拟机源码中摘抄的以下部分内容，该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，不会在直接操作字节流

### 元数据验证

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，这个阶段可能包括的验证点如下

* 这个类是否有父类（除了`java.lang.Object`之外，所有的类都应当有父类）
* 这个类的父类是否集成了不允许被继承的类（被`final`修饰的类）
* 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
* 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的`final`字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不相同等）

第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息

### 字节码验证

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对的元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的时间，例如

* **保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作**，例如不会出现类似这样的情况：在操作栈放置了一个`int`类型的数据，使用时却按`long`类型来加载入本地变量表中
* 保证跳转指令不会跳转到方法体以外的字节码指令上
* 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险不合法的

......

如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。

由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的事件消耗在字节码验证阶段，在 JDK1.6 之后的 `Javac`编译器和 Java 虚拟机进行了一项优化，给方法体的`Code`属性的属性表增加了一项名为`StackMapTable`的属性，作用如下

* 这项属性**描述了方法体中所有的基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态**，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查`stackMapTable`属性中的记录是否合法即可。这样可以节省时间

`StackMapTable`属性也存在错误或被篡改的可能

* 在 JDK1.6 的`HotSpot`虚拟机中提供了`-XX:-UseSplitVerifier`选项来关闭这项优化，使用参数`-XX:+FailOverToOldVerifier`要求在类型校验失败的时候退回到旧的类型推到方式进行校
* 在 JDK1.7 之后，对于主版本号大于 50 的 Class 文件，适用类型检查来完成数据流分析检验则是唯一的选择，不允许在退回到类型推导的校验方法

### 符号引用验证

最后一个阶段的**校验发生在虚拟机将符号引用转化为直接引用的时候**，将这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容

* 符号引用中通过字符串描述的全限定名是否能找到对应的类
* 在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段
* 符号引用中的类、字段、方法的访问性（`private`/ `protected`/ `public`/ `default`）是否可被当前类访问

......

**符号引用验证的目的是确保解析动作能正常执行**，如果无法通过符号引用验证，那么将会抛出一个`java.lang.IncompatibleClassChangeError`异常的子类，入`java.lang.IllegalAccessError`/ `java.lang.NoSuchFieldError`/ `java.lang.NoSuchMethodError`等

对于虚拟机的类加载机制来说，验证阶段是一个**非常重要但不一定必要**（因为对程序运行期没有影响）的阶段。如果所运行的代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间



## 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**在这个阶段中有两个容易产生混淆的概念。首先，这时候进行内存分配的仅包括类变量（被`static`修饰的变量），而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为

```java
public static int value = 123;
```

那变量`value`在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 `value`赋值为 123 的`putstatic`指令是程序被编译后，存放于类构造器`<client>()`方法之中，所以把`value`赋值为 123 的动作将在初始化阶段才会执行

| 数据类型 |   零值    | 数据类型  | 零值  |
| :------: | :-------: | :-------: | :---: |
|   int    |     0     |  boolean  | false |
|   long   |    0L     |   float   | 0.0f  |
|  short   | (short) 0 |  double   | 0.0d  |
|   char   | `\u0000`  | reference | null  |
|   byte   | (byte) 0  |           |       |

“特殊情况”：如果类字段的字段属性表中存在`ConstantValue`属性，那在准备阶段变量`value`就会被初始化`ConstantValue`属性所指定的值，假设上面类变量`value`的定义变为

```java
public static final int value = 123;
```

编译时 Javac 将会为`value`生成`ConstantValue`属性，在准备阶段虚拟机就会根据`ConstantValue`的设置将`value`赋值为 123



## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在 Class 文件中它以`CONSTANT_Class_info`/ `CONSTANT_Fieldref_info`/ `CONSTANT_Methodref_info`等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联

* 符号引用（Symbolic References）
  * **符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。**符号引用与虚拟机实现的内存布局无关，**引用的目标不一定已经加载到内存中**，各种虚拟机实现的内存布局可以各不相同，但是**它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中**
* 直接引用（Direct References）
  * **直接引用可以是直接指向目标的指针、相对偏移量或是一个能简介定位到目标的句柄**。直接引用是和虚拟机实现的内存布局相关的，**同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在**

虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行

* `anewarray`
* `checkcast`
* `getfield`
* `getstatic`
* `instanceof`
* `invokedynamic`
* `invokeinterface`
* `invokespecial`
* `invokestatic`
* `invokevirtual`
* `ldc`
* `ldc_w`
* `multianewarray`
* `new`
* `putfield`
* `putstatic`

这 16 个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它

对同一符号引用进行多次解析请求是很常见的事情，除`invokedynamic`指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中

* 如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；
* 如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常；

对于`invokedynamic`指令，以上规则不成立，当碰到某个前面已经有`invokedynamic`指令触发过解析的符号引用时，并不意味着这个解析结果对于其他`invokedynamic`指令也同样生效。因为`invokedynamic`指令的目的本来就是用于动态语言支持（目前仅使用 Java 语言不会生成这条字节码指令），他所对应的引用称为`动态调用点限定符(Dynamic Call Site Specifier)`，这里`动态`的含义就是**必须等到程序实际运行到这条指令的时候，解析动作才能进行**。相对的，其余可触发解析的指令都是`静态`的，**可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析**

解析动作主要针对

* 类或接口 -> `CONSTANT_Class_info`
* 字段 -> `CONSTANT_Fieldref_info`
* 类方法 -> `CONSTANT_Methodref_info`
* 接口方法 -> `CONSTANT_InterfaceMethodref_info`
* 方法类型 -> `COSTANT_MethodType_info`
* 方法句柄 -> `CONSTANT_MethodHandle_info`
* 调用点限定符 -> `CONSTANT_InvokeDynamic_info`

下面将讲解前面 4 中引用的解析过程，对于后面 3 种，与 JDK1.7 新增的动态语言支持息息相关，由于 Java 语言是一门静态类型语言，因此在没有介绍`invokedynamic`指令的语义之前，没有办法将他们和现在的 Java 语言对应上

### 类或接口的解析

假设当前代码所处的类为`D`，如果要把一个从未解析过的符号引用`N`解析为一个类或接口`C`的直接引用，那虚拟机完成整个解析的过程需要以下 3 个步骤

1. 如果`C`不是一个数组类型，那虚拟机将会把代表`N`的全限定名传递给`D`的类加载器去加载这个类`C`。在加载过程中，由于元数据验证，字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败
2. 如果`C`是一个数组类型，并且数组的元素类型为对象，也就是`N`的描述符会是类似`[Ljava/lang/Integer`的形式，那将会按照第 1 点的规则加载数组元素类型。如果`N`的描述符如前面所假设的形式，需要加载的元素类型就是`java.lang.Integer`，接着由虚拟机生成一个代表此数组维度和元素的数组对象
3. 如果上面的步骤没有出现任何异常，那么`C`在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认`D`是否具备对`C`的访问权限。如果发现不具备访问权限，将抛出`java.lang.illegalAccessError`异常

### 字段解析

要解析一个未被解析过的字段符号引用，首先将会对字段表内`class_index`项中索引的`CONSTANT_Class_info`符号引用进行解析，也就是字段所述的类或接口的符号引用，如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用`C`表示，虚拟机规范要求按照如下步骤对`C`进行后续字段的搜索

1. 如果`C`本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
2. 否则，如果在`C`中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
3. 否则，如果`C`不是`java.lang.Object`的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，结束查找
4. 否则，查找失败，抛出`java.lang.NoSuchFieldError`异常

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出`java.lang.IllegalAccessError`

在实际应用中，虚拟机的编译器实现可能会比上述规范要求的更加严格一些，如果有一个同名字段同时出现在`C`的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译

```java
public class FieldResolution {

    interface Interface0 {
        int A = 0;
    }
    interface Interface1 extends Interface0 {
        int A = 1;
    }
    interface Interface2 {
        int A = 2;
    }
    static class Parent implements Interface1 {
        public static int A = 3;
    }
    static class Sub extends Parent implements Interface2 {
        //public static int A = 4;
    }
    public static void main(String[] args) {
        System.out.println(Sub.A);
    }
    
}
```

例如这段代码，如果将注释放开，编译可以通过，但是没有放开时，编译器提示`The field Sub.A is ambiguous`，将继承`parent`换成实现`Interface0`或`Interface1`也会出现编译不通过，如果只实现`Interface0`和`Interface1`及继承`Parent`时，编译是可以通过的

### 类方法解析

类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的`class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用`C`表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索

1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现`class_index`中索引的`C`是个接口，那就直接抛出`java.lang.IncompatibleClassChangeError`异常
2. 如果通过了第 1 步，在类`C`中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
3. 否则，在类`C`的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有，则返回这个方法的直接引用，查找结束
4. 否则，在类`C`实现的接口列表及它们的父类接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配方法，说明类`C`是一个抽象类，这是查找结束，抛出`java.lang.AbstractMethodError`异常
5. 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出`java.lang.illegalAccessError`

### 接口方法解析

接口方法也需要先解析出接口方法表的`class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用`C`来表示这个接口，接下来虚拟机将会按照如下不走进行后续的接口方法搜索

1. 与类方法解析不同，如果在接口方法表中发现`class_index`中的索引`C`是个类而不是接口，那就直接抛出`java.lang.IncompatibleClassChangeError`异常
2. 否则，在接口`C`中查找是否有简单名称和描述符都与目标相匹配的方法，如果有，则返回这个方法的直接引用，查找结束
3. 否则，在接口`C`的父接口中递归查找，直到`java.lang.Object`类（查找范围会包括`Object`类）为止，看是否有简单名称和描述符都与目标相匹配的方法。如果有则返回这个方法的直接引用，查找结束
4. 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`异常

由于接口中所有的方法都默认是`public`的，所以不存在权限访问的问题，因此接口方法的符号解析应当不会抛出`java.lang.IllegalAccessError`异常



## 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化阶段，才真正开始执行类中定义的 Java 字节码

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观设计去初始化变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程。`<clinit>()`方法执行过程中可能会影响程序运行行为的特点和细节，这部分相对更贴近与普通的程序开发人员

* `<clinit>()`方法是由**编译器自动收集类中的所有类变量的赋值动作和静态语句块（`static{}`块）中的语句合并产生的，静态语句只能访问到定义在静态语句块之间的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问**，如下面代码在使用变量`i`时编译器报错

  ```java
  public class Test {
      static {
          i = 0;
          System.out.println(i); // Illegal forward reference
      }
      static int i = 1;
  }
  ```

* `<clinit>()`方法与类的构造函数（或者说实例构造器`<init>()`方法）不同，它不需要显式的调用父类构造器，**虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。因此在虚拟机中第一个被执行的`<clinit>()`方法的类肯定是`java.lang.Object`**

* 由于父类的`<clinit>()`方法先执行，也就意味着父类定义的静态语句块肯定要优先于子类的变量赋值操作

  ```java
  public class Test {
      static class Parent{
          public static int A = 1;
          static {
              A = 2;
          }
      }
      static class Sub extends Parent {
          public static int B = A;
      }
      public static void main(String[] args) {
          System.out.println(Sub.B); // 2
      }
  }
  ```

* `<clinit>()`方法对于类或接口来说并不是必需的，**如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法**

* 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成`<clinit>()`方法。但接口与类不同的是，**执行接口`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法。只有当父接口中定义的变量使用时，父接口才会初始化，另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法**

* 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，知道活动线程执行`<clinit>()`方法完毕。如果一个类的`<clinit>()`方法中有很耗时长的操作，就可能造成多个进程阻塞，在实际应用中，这种阻塞往往是很隐蔽的

  ```java
  public class Test {
  
      static class DeadLoopClass {
          static {
              // 不用 if 语句，编译器将提示"Initializer does not complete normally"
              if (true) {
                  System.out.println(Thread.currentThread() + "init DeadLoopClass");
                  while (true) {
                  }
              }
          }
      }
  
      public static void main(String[] args) {
          Runnable runnable = new Runnable() {
              public void run() {
                  System.out.println(Thread.currentThread() + "start");
                  DeadLoopClass deadLoopClass = new DeadLoopClass();
                  System.out.println(Thread.currentThread() + "run over");
              }
          };
          Thread thread1 = new Thread(runnable);
          Thread thread2 = new Thread(runnable);
          thread1.start();
          thread2.start();
      }
  }
  Thread[Thread-1,5,main]start
  Thread[Thread-0,5,main]start
  Thread[Thread-1,5,main]init DeadLoopClass
  ```