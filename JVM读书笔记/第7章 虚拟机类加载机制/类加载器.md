# 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到了 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为`类加载器`

类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，称为 Java 技术体系中一块重要的基石

## 类与类加载器

类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于类加载阶段。**对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。**这句话可以表达的更通俗一点：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等

这里所指的“相等”，包括代表类的 Class 对的的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法的返回结果，也包括使用`instanceof`关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果

```java
public class ClassLoaderTest {

    public static void main(String[] args) {
        ClassLoader myLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    if (is == null) {
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    return defineClass(name, b, 0, b.length);
                } catch (IOException e) {
                    throw new ClassNotFoundException(name);
                }
            }
        };
        Object obj = null;
        try {
            obj = myLoader.loadClass("com.yczuoxin.jvm.demo.classloader.classloader.ClassLoaderTest").newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(obj.getClass()); // class com.yczuoxin.jvm.demo.classloader.classloader.ClassLoaderTest
        System.out.println(obj instanceof com.yczuoxin.jvm.demo.classloader.classloader.ClassLoaderTest); // false
    }
}
```

上述代码构造了一个简单的类加载器`myLoader`，他可以加载与自己在同一路径下的 Class 文件。我们使用`myLoader`加载了一个名为`com.yczuoxin.jvm.demo.classloader.classloader.ClassLoaderTest`的类，并实例化了这个类的对象。两行输出结果中，从第一句可以看出，这个对象确实是类`com.yczuoxin.jvm.demo.classloader.classloader.ClassLoaderTest`实例化出来的对象，但从第二句可以发现，这个对象与类`com.yczuoxin.jvm.demo.classloader.classloader.ClassLoaderTest`做所属类型检查的时候返回了`false`，这是因为虚拟机存在了两个`ClassLoaderTest`类，一个是由系统应用程序类加载器加载的，另一个是由我们自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为`false`



## 双亲委派模型

从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器`Bootstrap ClassLoader`，这个类加载器使用`C++`语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都是由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类`java.lang.ClassLoader`

从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下 3 种提供的类加载器

* 引导类加载器或启动类加载器`Bootstrap ClassLoader`

  * 可以用`-Xbootclasspath/a:c:ClassLoaderTest.jar`或者将 Class 文件放在`JAVA_HOME/jre/classes/`目录下
  * 这个类将负责将存放在`JAVA_HOME\bin`目录中的，或者被`-Xbootclasspath`参数所指定的路径中的，并且是虚拟机是别的（仅按照文件名识别，如`rt.jar`，名字不符合的类库即使放在`lib`目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求为派给引导类加载器，如果需要把加载请求为派给引导类加载器，直接使用`null`代替即可。以下是获取类加载器的方法片段

  ```java
  // Returns the class's class loader, or null if none.
      static ClassLoader getClassLoader(Class<?> caller) {
          // This can be null if the VM is requesting it
          if (caller == null) {
              return null;
          }
          // Circumvent security check since this is package-private
          return caller.getClassLoader0();
      }
  ```

* 扩展类加载器`Extension ClassLoader`

  * 这个类加载器由`jdk.internal.loader.ClassLoaders$ExtClassLoader`（`JDK9`及以上）或`sun.misc.Launcher$ExtClassLoader`（`JDK8`及以下）实现，他负责加载`JAVA_HOME\bin\ext`目录中的，或者被`java.ext.dirs`系统变量所执行的路径中的所有类库，开发者可以直接使用扩展类加载器

* 应用程序类加载器`Application ClassLoader`

  * 这个类加载器由`jdk.internal.loader.ClassLoaders$AppClassLoader`（`JDK9`及以上）或`sun.misc.Launcher$AppClassLoader`（`JDK8`及以下）实现。由于这个类加载器时`ClassLoader`中的`getSystemClassLoader()`方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径`ClassPath`上所指定的类库，开发者可以直接使用这个类加载器，**如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器**

类加载器之间的层次关系如下

![类加载器层次关系](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fyorisuj7fj30gf0fxaa9.jpg)

这种层次关系，称为类加载器的双亲委派模型`Parents Delegation Model`。双亲委派模型要求除了顶层的引导类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承`Inheritance`的关系来实现，而是都使用组合`Composition`关系来复用父加载器的代码

### 双亲委派机制

某个特定的类加载器在接到加载类的请求时，首先将加载任务委托交给父类加载器，父类加载器又将加载任务向上委托，直到最父类加载器，如果最父类加载器可以完成类加载任务，就成功返回，如果不行就向下传递委托任务，由其子类加载器进行加载。与代理模式想法，代理模式是先尝试自己加载，如果无法加载则向上传递，如`tomcat`

* 好处：保证 Java 核心库的安全性（例如：如果用户自己写了一个`java.lang.String`类就会因为双亲委派机制不能被加载，不会破坏原生的`String`类的加载）

双亲委派模型用于保证 Java 程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在`java.lang.ClassLoader`的`loadClass()`方法之中。

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查请求的类是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 如果父类加载器抛出了 ClassNotFoundException
                    // 说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    // 在父类加载器无法加载的时候
                    // 在调用本身的 findClass 方法来进行加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // 这是定义的类加载器,记录统计数据
                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

## 破坏双亲委派模型

双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。双亲委派模型主要出现过 3 个较大规模的“被破坏”情况

### 第一次

发生在双亲委派模型出现之前——`JDK1.2`发布之前，那个时候类加载器和抽象类`java.lang.ClassLoader`则在 `JDK1.0`时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做一些妥协。为了向前兼容，`Java.lang.ClassLoader`添加了一个新的`protected`方法`findClass()`，在此之前，用户继承`Java.lang.ClassLoader`的目的就是为了重写`loadClass()`方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法`loadClassInternal()`，而这个方法的唯一逻辑就是去掉用自己的`loadClass()`

`JDK1.2`之后已经不提倡用户去覆盖`loadClass()`方法，应当把自己的类加载逻辑写到`findClass()`方法中，在`loadClass()`方法的逻辑里如果父类加载失败，则会调用自己的`findClass()`方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

### 第二次

是由这个模型自身的缺陷所导致的，双亲委派很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础“，是因为他们总是作为被用户代码调用的`API`，但世事往往没有绝对的完美，**如果基础类又要调用会用户的代码，那该怎么办？**

> 一个典型的例子便是`JNDI`服务，`JNDI`现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在`JDK1.3`时放进去的`rt.jar`），但`JDNI`的目的就是对资源进行集中管理和查找，他需要调用由独立厂商实现并部署在应用程序的`ClassPath`下的`JNDI`接口提供者`SPI，Service Provider Interface`的代码，但启动加载器不可能“认识”这些代码

为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计，**线程上下文类加载器`Thread Context ClassLoader`**。这个类加载器可以通过`java.lang.Thread`类的`setContextClassLoader()`方法进行设置，如果创建线程时还为设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载默认就是应用程序类加载器

有了线程上下文类加载器，就可以做一些“舞弊”的事情，**`JDNI`服务使用这个线程上下文类加载器去加载所需要的`SPI`代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。**Java 中所有涉及`SPI`的加载动作基本上都采用这种方式，如`JNDI`/ `JDBC`/ `JCE`/ `JAXB`/ `JBI`等

### 第三次

由于用户带程序动态性能的追求导致，动态性是指如：

* 代码热替换`HotSwap`
* 模块热部署`Hot Deployment`

等，说白了就是希望应用程序能像我们的计算及外设那样，接上鼠标、U盘等不用重启机器就能立即使用。

`JSR-291`（即`OSGi R4.2`）已经成为业界“事实上”的 Java 模块化标准，而`OSGi`实现模块化热部署的关键则是它自定义的类加载器机制实现。每一个程序模块（`OSGi`中为`Bundle`）都有一个自己的类加载器，当需要更换一个`Bundle`时，就把`Bundle`连同类加载器一起换掉以实现代码的热替换

### OSGi概述

在`OSGi`环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载器请求时，`OSGi`将按照下面的顺序进行类搜索

1. 如果类或者资源是在包`java.*`中，那么交由父级类加载器代理完成，否则，搜索过程进入第二步。如果父类级类加载器加载失败，那么查找过程结束，加载失败
2. 如果类或者资源在启动代理序列`org.osgi.framework.bootdelegation`中定义，那么交由父级代理完成，此时的父级代理有启动参数`org.osgi.framework.bundle.parent`指定，默认是引导类加载器`bootstrap class loader`，如果找到了类或者资源，那么查找过程结束
3. 如果类或者资源所在的包是在`Import-Package`中指定的，或者是在此之前通过动态导入加载的了，那么将请求转发到导出`Bundle`的类加载器，否则搜索继续进行下一步；如果该包在启动参数`org.osgi.framework.system.packages.extra`中，则将请求转发给`OSGi`容器外部的类加载器（通常是系统类加载器）。如果将请求交由导出类加载器代理，而类或者资源又没有找到，那么查找过程中止，同时请求失败
4. 如果包中类或者和资源所在的包由其他`Bundle`通过是使用`Require-Bundle`从一个或多个其他`Bundle`进行导入的了，那么请求交由其他那些`Bundle`的类加载器完成，按照根据在`Bundle`的`Manifest`中指定的顺序进行查找进行查找。如果没有找到类或者资源，搜索继续进行
5. 使用`Bundle`本身的内部`Bundle`类路径查找完毕之后，。如果类或者资源还没有找到，搜索继续到下一步
6. 查找每一个附加的`Fragment`的内部类路径，`Fragment`的查找根据`Bundle ID`顺序升序查找。如果没有找到类或者资源的，查找过程继续下一步
7. 如果包中类或者资源所在的包由`Bundle`导出，或者包由`Bundle`导入（使用`Import-Package`或者`Require-Bundle`），查找结束，即类或者资源没有找到
8. 否则，如果类或者资源所在的包是通过使用`DynamicImport-Package`进行导入，那么试图进行包的动态导入。导出者`exporter`必须符合包约束。如果找到了合适的导出者`exporter`，然后建立连接，以后的包导入就可以通过步骤三进行。如果连接建立失败，那么请求失败
9. 如果动态导入建立了，请求交由导出`Bundle`的类加载器代理。如果代理查找失败，那么查找过程中止，请求失败

类加载的优先级顺序基本按照如下的原则：父容器`Classloader`（通常是`Application Classloader`） –> 其他`Bundle`的`Classloader` –> 当前`Bundle`的`Classloader` –> 动态导入的包所在`Bundle`的`Classloader`。这个原则既可以使相同的类（包名也相同）尽可能只被加载一次，减少虚拟机`perm`区大小，也正因为如此，不同`Bundle`中的相同的类，委托给同一个`Classloader`加载，才能做到他们的对象和引用可以相互转换