# Java虚拟机历史

## 名词解释

* JIT
  * just in time compiler:为了提高热点代码的执行效率,在运行时,虚拟机将把这些代码编译成与 本地平台相关的机器码,并进行各种层次的优化,完成这个任务的编译器称为即时编译器.
* 热点代码
  * 当虚拟机发现某个方法或代码块运行特别频繁,就会把这些代码认定为热点代码.

## 虚拟机进化史

* 1996.1.23 Sun公司发布JDK1.0 使用的虚拟机Classic VM

* 1998年后, Solaris平台发布 Exact VM

* 1999.4.27 Longview Technologies公司(1997年被Sun公司收购)发布虚拟机HotSpot VM

## 虚拟机对比

### Classic VM(1.2之前唯一且默认,1.4退出)

* 特性
  * 只能使用纯解释器方式执行java代码
  * 如果外挂了JIT编译器,解释器就不再工作了
    * 解释器的优势: 当程序需要迅速启动和执行的时候,解释器可以首先发挥作用,省去编译的时间,立即执行.
    * 编译器的优势: 在程序运行后,随着时间的推移,编译器逐渐发挥作用,把越来越多的代码编译成本地代码之后,可以获得更高的执行效率.
* 缺点
  * 执行效率很低
  * 基于handler的对象查找方式,GC后可能被移动位置,在没有明确内存中哪些数据是reference的前提下,不敢把对象地址位置切换,所以使用句柄来维持reference值的稳定



### Exact VM

* 特性
  * 实现两级即时(编译器, 编译器和解析器混合工作模式)
  * 准确式内存管理(虚拟机知道内存中某个位置的数据具体是什么类型)
* 优点
  * GC时可以准确判断堆上的数据是否还可能被使用,提升性能



### HotSpot VM

* 特性
  * 继承了以上两个虚拟机的优点
  * 热点代码探测技术
    * 通过执行计数器找出最具有编辑价值的代码,交给JIT编译器以方法为单位进行编译
    * 如果**频繁调用**或者**有效循环次数很多**,会分别触发标准编译和OSR(栈上替换)编译动作
      * OSR
        * 编译动作是由循环体所触发的,编译器依然会以整个方法作为编译对象,编译发生在方法执行过程之中,方法栈帧还在栈上,方法就被替换了.
* JIT即时编译器
  * Client Compiler(C1) ,编译速度快,可以使用`-client`强制虚拟机运行在 Client 模式
  * Server Compiler(C2) ,编译质量好,在解释执行的时候也无须再承担收集性能监控信息的任务,可以使用`-server`强制虚拟机运行在 Server 模式
* 分层编译: 使程序启动相应速度与运行效率之间达到最佳平衡的策略
  * 第0层
    * 程序解释执行,解释器不开启性能监控功能,可触发第1层编译.
  * 第1层(C1编译)
    * 将字节码编译为本地代码,进行简单,可靠的优化,如有必要时将加入性能监控的逻辑.
  * 第二层(C2编译)
    * 也是将字节码编译为本地代码,但是会启动一些编译耗时较长的优化,甚至会根据性能监控信息进行一些不可靠的激进优化.

### BEA JRockit(BEA公司)

* 特性
  * 专门为服务器硬件和服务器应用场景高度优化的虚拟机
  * 不太关注程序启动速度(不包含解析器实现,全靠及时编译器编译后执行)
  * 垃圾收集器和MissionControl服务套件等部分处于领先水平

### IBM J9 VM(IBM)

* 特性
  * 定位与HotShot接近,开发目的是作为IBM公司各种Java产品的执行平台.



> 参考资料
>
> 周志明. 深入理解JVM虚拟机