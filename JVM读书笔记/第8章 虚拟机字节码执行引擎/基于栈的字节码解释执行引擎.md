# 基于栈的字节码解释执行引擎

本节讨论虚拟机是如何执行方法中字节码指令的。许多 Java 虚拟机的执行引擎在执行 Java 代码的时候都有解释执行和编译执行两种选择。

> 在 Java 初生的 JDK 1.0 时代，Java 语言是解释执行的语言，但当主流的虚拟机中都包含了即时编译器后， Class 文件中代码到底被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java 业发展出了可以直接生成本地代码的编译器，如 GCJ`GUN Compiler for the Java`，而 C/C++ 语言也出现了通过解释器编译的版本，如 CINT，这时候在笼统的说解释执行，对于整个 Java 语言来说就成了几乎是没有意义的概念，只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎模式时，谈解释执行还是编译执行才会比较确切



## 解释执行

大部分的程序代码到物理机的目标代码或虚拟机能执行的指令集之前都需要经历以下的步骤

![TIM截图20190130100254](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzodskuuxvj30u70da0z8.jpg)

下面一条分支是传统编译原理中程序代码到机器代码的生成过程，而中间的那条分支，自然就是解释执行的过程

现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树`AST Avstract Syntax Tree`，对于一门具体语言的实现来说，词法分析、语法分析以至后面的优化器目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是 C/C++ 语言。也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是 Java 语言。又或者把这些步骤和执行引擎全部集中分装在一个封闭的黑匣子之中，如大多数的 JavaScript 执行器

Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现



## 基于栈的指令集与基于寄存器的指令集

Java 编译器输出的指令流，基本上是一种**基于栈的指令集架构`Instruction Set Architecture,ISA`**，大部分字节码指令集会带有参数，而纯粹基于栈的指令集架构中应当全部是零地址值指令，也就是都不存在显式的参数，Java 这样的实现主要是考虑了代码的可校验性，他们依赖操作数栈进行工作。与之对应的是**基于寄存器的指令集**，最典型的上就是 x86 的二地址指令集，说的通俗一点，就是现在我们主流的 PC 机中直接支持的指令集架构，这些指令依赖寄存器进行工作。

### 不同点

举个例子，分别使用这两种指令集计算 1 + 1 的结果

* 基于栈的指令集，两条`iconst_1`指令连续把两个常量 1 压入栈后，`iadd`指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后`istore_0`把站定的值存到局部变量表的第 0 个`Slot`中

```properties
iconst_1
iconst_1
iadd
istore_0
```

* 基于寄存器的指令集，`mov`指令把 EAX 寄存器的值设为 1，然后`add`指令再把这个值加 1，结果就保存在 EAX 寄存器里面

```properties
mov eax, 1
add eax, 1
```

### 优势

* 基于栈的指令集：
  * 可移植性强
  * 可以让虚拟机决定将访问最频繁的数据放到寄存器中获取更好的性能
  * 代码相对更紧凑，字节码中每个字节就对应一条指令，多地址指令集中还需要存放参数
  * 编译器实现更加简单，不需要考虑空间分配问题，都在栈上操作
* 基于寄存器的指令集
  * 速度快，出栈、入栈操作本身就产生了相当多的指令数量，并且栈实现在内存中，对于处理器而言，内存始终是执行速度的瓶颈



## 基于栈的解释器执行过程

执行代码

```java
public class CalcDemo {
    public static void main(String[] args) {
        calc();
    }

    public static int calc() {
        int a = 100;
        int b = 200;
        int c = 300;
        return (a + b) * c;
    }
}
```

查看编译

```properties
  public static int calc();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=0
         0: bipush        100
         2: istore_0
         3: sipush        200
         6: istore_1
         7: sipush        300
        10: istore_2
        11: iload_0
        12: iload_1
        13: iadd
        14: iload_2
        15: imul
        16: ireturn
```

* 首先执行偏移地址为 0 的指令，`bipush`指令的作用是将单字节的整型常量值（-128 ~ 127）推入操作数栈顶，跟随有一个参数，指明推送的常量值，这是 100
* 执行偏移地址为 2 的指令，`istore_1`指令的动作是将操作数栈顶的整型值出栈并存放到第 1 个局部变量`Slot`中，后续 4 条指令（知道偏移为 11 的指令为止）都是做一样的事情，也就是在对应代码中把变量 a、b、c 赋值为 100、200、300，这 4 条指令
* 执行偏移地址为 11 的指令，`iload_1`指令的作用是将局部变量表第 0 个`Slot`中的整型值复制到操作数栈顶
* 执行偏移地址为 12 的指令，`iload_2`指令的执行过程与`iload_1`类似，把第 1 个`Slot`的整型植入栈
* 执行偏移地址为 13 的指令，`iadd`指令的作用是将操作数栈中头两个栈顶元素出栈，做整型加法，然后把结果重新入栈
* 执行偏移地址为 14 的指令，`iload_3`指令把存放在第 2 个`Slot`的 300 压入栈，这时操作数栈的两个整数 300
* 执行偏移地址为 15 的指令，下一条指令`imul`是将操作数栈中头两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，与`iadd`完全类似
* 执行偏移地址为 16 的指令，`ireturn`指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给此方法的调用者

上面执行只是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述......更确切地说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和编译器都会对输入的字节码进行优化，例如在`HotSpot`虚拟机中，很多以`fast_`开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，而即时编译器的优化手段更加花样繁多