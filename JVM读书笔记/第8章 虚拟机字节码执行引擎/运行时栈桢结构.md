# 运行时栈桢结构

## 栈桢`Stack Frame`

- 概念：用于支持虚拟机进行**方法调用**和**方法执行**的数据结构，他是虚拟机运行时数据区中的**虚拟机栈`Virtual Machine Stack`**的**栈元素**。

- 结构

  - 局部变量表`Local Variable Table` 

  - 操作数栈`Operand Stack`

  - 动态连接`Dynameic Linking`

  - 方法返回地址

  - 附加信息

每一个方法从调用开始至执行结束的过程，都对应着一个栈桢在虚拟机栈里面从入栈到出栈的过程

**在编译程序代码的时候，栈桢中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的`Code`属性之中，因此一个栈桢需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现**

在活动线程中，只有位于栈顶的栈桢才是有效的，称为**当前栈桢`Current Stack Frame`**，与这个栈桢相关联的方法称为**当前方法`Current Method`**。执行引擎运行的所有字节码指令都与针对当前栈桢进行操作。

## 局部变量表

* 概念：一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
* 最大容量：在 Java 程序编译为 Class 文件时，方法的`Code`属性的`max_locals`数据项中确定。
* 单位：变量槽`Slot`
> 虚拟机规范没有明确指明一个`Slot`应占用的内存空间大小，只是很有向导性的说每个`Slot`都应该能存放一个`boolean`/ `byte`/ `char`/ `short`/ `int`/ `float`/ `reference`/ `returnAddress`类型的数据，这 8 种数据类型，都可以使用 32 位或更小的物理内存来存放，它允许`Slot`的长度随着处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在 64 位虚拟机中使用了 64 位的物理内存空间去实现一个`Slot`，虚拟机仍要使用对其和补白的手段让`Slot`在外观上看起来与 32 位虚拟机中的一致

### Java 虚拟机的数据类型

#### 32 位的数据类型

* `boolean`
* `byte`
* `char`
* `short`
* `int`
* `float`
* `reference` -> 不确定其大小，虚拟机规范没有明确规定其长度，它与实际使用 32 位还是 64 位虚拟机有关，如果是 64 位，还与是否开启某些对象指针压缩的优化有关
* `eturnAddress` -> 已经很少见了，它指向一条字节码地址，现在已经由异常表代替

Java 语言与 Java 虚拟机中的基本数据类型是存才本质差别的，前 6 中可以按照 Java 语言中对应数据类型的概念去理解它们，而`reference`类型表示对一个对象实例的引用，**虚拟机规范没有说明它的长度，也没有明确指出这种引用应有怎样的结构。**但一般来说，**这个引用要做到两点**

1. 从此引用中直接或间接的查找到对象在 Java 堆中的数据存放的起始地址索引
2. 从此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息

对于 64 位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的`Slot`空间。

#### 明确的 64 位的数据类型

* `long`
* `double`

这两种数据类型分割存储的做法与"`long`和`double`的非原子性协定"中把一次`long`和`double`数据类型读写分割为两次 32 位读写的做法类似。由于局部变量表建立在线程的堆栈上，是线程私有的数据，所以不会导致安全问题

#### 索引

虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始至局部变量表的最大的`Slot`数量。如果访问的是 32 位数据类型的变量，索引 n 就代表了使用第 n 个`Slot`，如果是 64 位数据类型的变量，则说明会同时使用 n 和 n+1 两个`Slot`，**对于两个相邻的共同存放一个 64 位数据的两个`Slot`，不允许采用任何方式单独访问其中的某一个，`Java`虚拟机中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的*校验阶段*抛出异常**

如果执行的实例方法（非`static`方法），那局部变量表中第 0 为索引的`Slot`默认是用于传递方法所属对象实例的引用，方法中可以用`this`来访问这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量`Slot`，**参数表分配完毕后**，再根据**方法体内部定义**的**变量顺序**和**作用域分**配其余的`Slot`

#### 重新利用

局部变量表中的`Slot`是可以重用的，方法体中定义的变量其作用域不一定会覆盖整个方法体，如果当前字节码`PC计数器`的值已经超出了某个变量的作用域，那这个变量对应的`Slot`就可以交给其他变量使用。

这样的设计除了节省栈桢空间外，会伴随一些额外的副作用，例如，在某些情况下，会影响到系统的垃圾收集行为

```java
/**
 *  VM options: -verbose:gc
 */
public class SlotDemo1 {
    public static void main(String[] args) {
        byte[] placeholder = new byte[64 * 1024 * 1024];
        System.gc();
    }
}
[GC 68157K->66232K(249856K), 0.0011717 secs]
[Full GC 66232K->66091K(249856K), 0.0095993 secs]
```

```java
/**
 *  VM options: -verbose:gc
 */
public class SlotDemo2 {
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        System.gc();
    }
}
[GC 69468K->66200K(249856K), 0.0009860 secs]
[Full GC 66200K->66101K(249856K), 0.0091782 secs]
```

```java
/**
 *  VM options: -verbose:gc
 */
public class SlotDemo3 {
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        int a = 0;
        System.gc();
    }
}
[GC 69468K->66232K(249856K), 0.0011070 secs]
[Full GC 66232K->565K(249856K), 0.0097101 secs]
```

`placeholder`能否被回收的根本原因是：局部变量表中的`Slot`时候还存有关于`placeholder`数组对象的引用。第一次修改虽然已经离开了`placeholder`的作用域，但在此之后，没有任何对局部变量表的读写操作，`placeholder`原本所占用的`Slot`还没有被其它变量所复用，所以作为`GC Root`一部分的局部变量表仍然保持着对它的关联。这种关联没有及时打断，在绝大部分情况下影响都很轻微。如果遇到一个方法，其后面的代码有一些耗时很长的操作，而在前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为`null`值便不见得是一个绝对无意义的操作。（这就是书上写的`不使用的对喜爱那个应手动赋值为null`的原因）。

但是手动赋值为`null`尽在某些情况下有用，但不应当过分依赖，`JIT编译器`是虚拟机执行代码的主要方式，赋值`null`的操作在经过`JIT编译`优化后会被消除掉，这时候变量赋值为`null`就是没有意义的。



## 操作数栈

* 概念：也称为操作栈，它是一个后入先出（Last In First Out）栈。
* 最大容量：在 Java 程序编译为 Class 文件时，方法的`Code`属性的`max_stacks`数据项中确定。

一个方法在刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是`出栈/入栈`操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者调用其他方法的时候使用过操作数栈来进行参数传递的

> 举个例子，整数加法的字节码指令`iadd`在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个`int`类型的数值，当执行这个指令时，会将这两个`int`值出栈并相加，然后将相加结果入栈

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再验证这一点

在概念模型中，两个栈桢作为虚拟机栈元素，是完全互相独立的。但**在大多数虚拟机的实现里都会做一些优化处理，令两个栈桢出现一部分重叠。让下面栈桢的部分操作数栈与上面栈桢的部分局部变量表重叠在一起，这样在进行方法调用时就可以公用一部分数据，无须进行额外的参数复制传递。**

**Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈**



## 动态连接

* 概念：每个栈桢都包含一个指向运行时常量池中该栈桢所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接`Dynamic Linking`。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。



## 方法返回地址

当一个方法执行后，只有两种方式可以退出这个方法

* 正常完成出口`Normal Method Invocation Completion`
  * 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定
* 异常完成出口`Abrupt Method Invocation Completion`
  * 在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用`athrow`字节码指令产生的异常，**只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出**。*这种退出是不会给它的上传调用者产生任何返回值的*

无论采用何种退出方式，方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈桢中保存一些信息，来帮助恢复它的上层方法的执行状态。

一般来说

* 方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈桢中很可能会保存这个计数器值。
* 方法异常退出时，返回地址是要通过异常处理器来确定的，栈桢中一般不会保存这部分信息

方法退出的过程实际就是把当前栈桢出栈，因此退出时可能执行的操作有

* 恢复上层方法的局部变量表和操作数栈
* 把返回值（如果有的话）压入调用者栈桢的操作数栈中
* 调整 PC 计数器的值以指向方法调用指令后面的一条指令等



## 附加信息

虚拟机允许具体的虚拟机实现增加一些规范里没有描述的信息到栈桢之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现



**动态连接、方法返回地址与其他附加信息全部归为一类，称为栈桢信息**

