# 方法调用

## 概念

**方法调用不等同于方法执行**，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。

在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class 文件的编译过程中不包含传统编译中的连接步骤，**一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。**这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

## 解析

所有方法调用中的目标方法在 Class 文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，前提是：**方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的**。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为**解析`Resolution`**

在 Java 语言中符合`编译期可知，运行期不可变`这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这**两种方法各自的特带你决定了他们都不能通过继承或别的方式重写其他版本，因此他们都适合在类加载阶段进行解析。**

与之对应的是，在 Java 虚拟机里面提供了 5 条方法调用字节码指令，分别如下

* `invokestatic`：调用静态方法
* `invokespecial`：调用实例构造器`<init>`方法、私有方法和父类方法
* `invokevirtual`：调用所有的虚方法
* `invokeinterface`：调用接口方法，会在运行时再确定一个实现此接口的对象
* `invokedynaminc`：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法

在此之前的 4 条调用指令，分派逻辑是固定在 Java 虚拟机内部的，而`invokedynamic`指令的分派逻辑是由用户所设定的引导方法决定的

**只要能被`invokestatic`和`invokespecial`指令调用的方法，都可以在解析阶段中确定唯一的调用版本，它们在类加载的时候就会把符号引用解析为该方法的直接引用**，符合条件的方法

* 静态方法
* 私有方法
* 实例构造器
* 父类方法

这些方法都可以称为非虚方法，与之相反，其他方法称为虚方法（除去`final`方法，虽然`final()`是使用`invokevirtual`指令调用的，但是由于它无法被覆盖，没有其他版本，所以无须对方法接收者进行多态选择，又或者多态选择的结果肯定是唯一的。Java 语言规范中明确说明了`final()`方法是一种非虚方法）。

```java
public class StaticResolution {
    public static void sayHello () {
        System.out.println("hello world");
    }

    public static void main(String[] args) {
        StaticResolution.sayHello();
    }
}
```

该代码中，静态方法`sayHello()`只能属于类型`StaticResolution`，没有任何手段可以覆盖或隐藏这个方法，使用`javap -verbose StaticResolution`查看这段程序的字节码

```properties
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=0, locals=1, args_size=1
         0: invokestatic  #5                  // Method sayHello:()V
         3: return
      LineNumberTable:
        line 12: 0
        line 13: 3
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       4     0  args   [Ljava/lang/String;

```

**解析调用一定是个静态的过程**，而分派调用则可能是静态的，也可能是动态的，根据分派依据的宗量数课分为单分派和多分派。这两类分派方式的两两组合就构成了

* 静态单分派
* 静态多分派
* 动态单分派
* 动态多分派



## 分派`Dispatch`

分派调用过程将会揭示多态性特征的一些最基本的提现，如`重载`和`重写`在 Java 虚拟机之中是如何实现的

### 静态分派

```java
public class StaticDispatch {

    static abstract class Human {
    }

    static class Man extends Human {
    }

    static class Woman extends Human {
    }

    static void sayHello (Human guy) {
        System.out.println("hello guy");
    }

    static void sayHello (Man guy) {
        System.out.println("hello man");
    }

    static void sayHello (Woman guy) {
        System.out.println("hello woman");
    }

    public static void main(String[] args) {
        // 实际类型变化
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch dispatch = new StaticDispatch();
        dispatch.sayHello(man);
        dispatch.sayHello(woman);
        // 静态类型变化
        dispatch.sayHello((Man) man);
        dispatch.sayHello((Woman) woman);
    }
}

hello guy
hello guy
hello man
hello woman
```

上述代码实际上是在考验对重载的理解程度，为什么会选择执行参数类型为`Human`的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要的概念

```java
    Human man = new Man();
```

我们把上面代码中的`Human`称为变量的**静态类型`Static Type`**，或者叫做的外观类型`Apparent Type`，后面的`Man`则称为变量的**实际类型`Actual Type`**，静态类型和实际类型在程序中都可以发生一些变化，区别

* 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并最终的静态类型是在编译器可知的
* 实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么

在方法接受者已经确定是对象`dispatch`的前提下，使用哪个重载版本，完全取决于传入参数的数量和数据类型。代码中可以的定义了两个静态类型相同但实际类型不同的变量，但**虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的。**静态类型是编译期可知的，因此，**在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪个重载版本**

所有依赖静态类型来定位方法执行版本的分派动作的功能为**静态分派**。静态分派的典型应用是方法重载。**静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。**编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。这种模糊的结论在由 0 和 1 构成的计算机世界中算是比较“稀罕”的事情，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型智能通过语言上的规则去理解和推断

```java
public class Overload {
    public static void sayHello (Object arg) {
        System.out.println("hello Object");
    }

    public static void sayHello (int arg) {
        System.out.println("hello int");
    }

    public static void sayHello (long arg) {
        System.out.println("hello long");
    }

    public static void sayHello (Character arg) {
        System.out.println("hello Character");
    }

    public static void sayHello (char arg) {
        System.out.println("hello char");
    }

    public static void sayHello (char... arg) {
        System.out.println("hello char ...");
    }

    public static void sayHello (Serializable arg) {
        System.out.println("hello Serializable");
    }

    public static void main(String[] args) {
        sayHello('a');
    }
}
```

上面的代码会输出

```properties
hello char
```

很显然，`'a'`是一个`char`类型的数据，自然会寻找参数类型为`char`的重载方法，如果注释掉`sayHello(char arg)`方法，输出会变为

```properties
hello int
```

这时发生了一次自动类型转换，`'a'`除了可以代表一个字符串，还可以代表数字 97（Unicode），因此参数类型为`int`的重载也是合适的，继续注释掉`sayHello(int arg)`方法，输出会变为

```properties
hello long
```

这时发生了两次自动类型转换，`'a'`转换为整数 97 之后，进一步转型为长整数 97L，匹配了参数类型为`long`的重载，代码中没有写其他的类型如`float`、`double`等的重载，不是实际上自动转型还是能继续发生多次，按照`char` -> `int` -> `long` -> `float` -> `double`的顺序转型进行匹配。但不会匹配到`byte`和`short`类型的重载，因为`char`到`byte`或`short`的转型是不安全的。继续注释掉`sayHello(long arg)`方法，输出会变为

```properties
hello Character
```

这时发生了一次自动装箱，`'a'`被包装为它的封装类型`java.lang.Character`，所以匹配到了参数为`Character`的重载，继续注释掉`sayHello(Character arg)`方法，输出会变为

```properties
hello Serializable
```

因为`Java.lang.Character`是`java.lang.Serializable`的一个实现类，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型，`char`可以转型成`int`，但是`Character`是绝对不会转型为`Integer`的，它只能安全的转型为他实现的接口或父类。`Character`还实现了另外一个接口`java.lang.Comparable<Character>`，如果同时出现两个参数分别为`Serializable`和`Comparable<Character>`的重载方法， 那它们在此时的优先级一样。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显式的指定字面量的静态类型，如：`sayHello((Comparable<Character>)'a')`，才能编译通过。继续注释掉`sayHello(Character arg)`方法，输出会变为

```properties
hello Object
```

这时是`char`装箱后转型为父类了，如果有多个父类，拿奖在继承关系中国年从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为`null`时，这个规则仍然适用。继续注释掉`sayHello(Object arg)`方法，输出会变为

```properties
hello char ...
```

7 个重载方法已经被注释的只剩下一个了，可见变长参数的重载优先级是最低的，这时候字符`'a'`被当做一个数组元素。笔者使用的是`char`类型的变长参数，读者在验证时还可以选择`int`类型、`Character`类型、`Object`类型等的变长参数重载来把上面的过程重新演示一遍。~~但要注意的是，有一些在单个参数中能成立的自动转型，如`char`转`int`，在变长参数中是不成立的。~~

这个过程是 Java 语言实现方法重载的本质，无论对重载的认识有多深刻，一个合格的程序员都不应该在实际应用中写出如此极端的重载代码

另外还有一点容易会混淆：**解析和分派这两者的关系并不是二选一的排他关系，他们是在不同层次上去筛选、确定目标方法的过程。**例如，前面说过，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的



### 动态分派

它和多态性的另一个重要提现——重写`Override`有着很密切的关联。还是用前面的`Man`和`Woman`一起`sayHello`的例子来讲解动态分派

```java
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void sayHello();
    }

    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        }
    }

    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}

man say hello
woman say hello
woman say hello
```

对于习惯了面向对象思维的 Java 程序员会觉得这是完全理所当然的，现在的问题还是和之前一样，虚拟机如何知道要调用那个方法的？

显然这里不可能再根据静态类型来决定，因为静态类型同样都是`Human`的两个变量`man`和`woman`在调用`sayHello()`方法时执行了不同的行为，并且变量`man`在两次调用中执行了不同的方法。

导致这个现象的原因很明显，是这两个变量的实际类型不同，Java 虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用`javap -verbose DynamicDispatch`命令输出这段代码的字节码，尝试从中需找答案

```properties
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Man
         3: dup
         4: invokespecial #3                  // Method com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Man."<init>":()V
         7: astore_1
         8: new           #4                  // class com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Woman
        11: dup
        12: invokespecial #5                  // Method com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Woman."<init>":()V
        15: astore_2
        16: aload_1
        17: invokevirtual #6                  // Method com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Human.sayHello:()V
        20: aload_2
        21: invokevirtual #6                  // Method com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Human.sayHello:()V
        24: new           #4                  // class com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Woman
        27: dup
        28: invokespecial #5                  // Method com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Woman."<init>":()V
        31: astore_1
        32: aload_1
        33: invokevirtual #6                  // Method com/yczuoxin/jvm/demo/resolution/DynamicDispatch$Human.sayHello:()V
        36: return
```

0 ~ 15行的字节码是准备动作，作用是建立`man`个`woman`的内存空间、调用`Man`和`Woman`的内存空间、调用`Man`和`Woman`类型的实例构造器，将这两个实例的引用存放在第 1，2 个局部变量表`Slot`之中，这个动作也就对应了代码中的这两句：

```java
Human man = new Man();
Human woman = new Woman();
```

接下来的 16 ~ 21 句是关键部分，16、20 两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的`sayHello()`方法的所有者，称为**接收者`Receiver`**；17 和 21 句是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是`invokevirtual`）还是参数（都是常量池中第 6 项的常量，注释显示了这个常量是`Human.sayHello()`的符号引用）完全一样，但是这两句指令最终指定的目标方法并不相同。原因就需要从`invokevirtual`指令的多态查找过程开始说起，`invokevirtual`指令的运行时解析过程大概分为以下几个步骤

1. 找到操作数栈栈顶的第一个元素所指向的对象的实际类型，记作 C
2. 如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError`异常
3. 否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程
4. 如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError`异常

由于`invokevirtual`指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的`invokevirtual`指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质

我们把这种在运行期根据实际类型类型确定方法执行版本的分派过程称为**动态分派**

### 单分派与多分派

方法的接收者和方法的参数统称为方法的**宗量**，可以将分派划分为单分派和多分派两种。

* 单分派 -> 根据一个宗量对目标方法进行选择
* 多分派 -> 根据多于一个宗量对目标方法进行选择

```java
public class Dispatch {
    static class QQ {}
    static class _360 {}

    public static class Father {
        public void hardChoice(QQ arg){
            System.out.println("father choose qq");
        }

        public void hardChoice(_360 arg){
            System.out.println("father choose 360");
        }
    }

    public static class Son extends Father {
        @Override
        public void hardChoice(QQ arg){
            System.out.println("son choose qq");
        }

        @Override
        public void hardChoice(_360 arg){
            System.out.println("son choose 360");
        }
    }

    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ());
    }
}

father choose 360
son choose qq
```

看看**编译阶段**编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：

* 静态类型是`Father`还是`Son`
* 方法参数是`QQ`还是`360`

这次选择最终产物是产生了两条`invokevirtual`指令，两条指令的参数分别为常量池中指向`Father.hardChoice(360)`及`Father.hardChoice(QQ)`方法的符号引用。因为是根据两个宗量进行选择，所以 Java 语言的**静态分派属于多分派类型**

再看**运行阶段**虚拟机的选择过程，也就是动态分派的过程。在执行`son.hardChoice(new QQ())`这句代码时，更准确的说，是在执行这句代码所对应的`invokevirtual`指令时，**由于编译期已经决定目标方法的签名必须为`hardChoice(QQ)`**，虚拟机此时不会关心传递过来的参数`QQ`到底是`腾讯QQ`还是`奇瑞QQ`，因为**这时参数的静态类型、实际类型都对方法的选择不会构成任何影响**，唯一可以影响虚拟机选择的因素只有此方法的接收者的实际类型是`Father`还是`Son`。因为只有一个宗量作为选择依据，所以 Java 语言的**动态分派属于单分派类型**

### 虚拟机动态分派的实现

虚拟机如何做到分派的，各种虚拟机的实现都会有些差别。

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正的进行如此频繁的搜索。面对这种情况，最常用的`稳定优化`手段就是为**类在方法区中建立一个`虚方法表Vritual Method Table(vtable)`**，与之对应的，在`invokeinterface`执行时也会用到接口方法表——`Inteface Method Table(itable)`，使用虚方法表索引来代替元数据查找以提高性能。

![TIM截图20190125171443](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fziy6p7fwsj30s40jctfd.jpg)

**虚拟方法表中功能存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。**上图，`Son`重写了来自`Father`的全部方法，因此`Son`的方法表没有指向`Father`类型数据的箭头。但是`Son`和`Father`都没有重写来自`Object`的方法，所以方法表中所有从`Object`继承来的方法都指向了`Object`的数据类型

为了程序实现上方便，**具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引号**，这样当类型变换时，仅需要变更查找方法的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址

**方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕**

上文笔者说方法表是分派调用的`稳定优化`手段，虚拟机除了使用方法表之外，在条件允许的情况下，还会使用内联缓存`Inline Cache`和基于“类型继承关系分析”`Class Hierarchy Analysis, CHA`技术的守护内联`Guarded Inlinging`两种非稳定的`激进优化`手段来获得更高的性能。



## 动态类型语言支持

Java 虚拟机的字节码指令集的数量从 Sun 公司的第一款 Java 虚拟机问世至 JDK 7 来临之前的十余年时间里，一直没有发生任何变化。随着 JDK 7 的发布，字节码指令集加入了`invokedynamic`指令。这条新增加的指令是 JDK 7 实现“动态类型语言”`Dynamically Typed Language`支持而进行的改进之一，也是为 JDK 8 可以实现 Lambda 表达式做技术准备

### 动态语言类型

动态类型语言与动态语言、弱类型语言并不是一个概念。**动态类型语言的关键特性是它的类型检查的主体过程是在运行期而不是编译期**，满足这个特性的语言有`API`/ `Clojure`/ `Erlang`/ `Groovy`/ `JavaScript`/ `Jpthon`/ `Lisp`/ `Lua`/ `PHP`/ `Prolog`/ `Python`/ `Ruby`/ `Smallltalk`/ `Tcl`等。相对的，在编译期就进行类型检查的语言（如`C++`和`Java`等）就是最常用的静态类型语言。`编译期/运行期进行`进行`类型检查`，什么是编译期/运行期？

```java
public class Demo {
    public static void main(String[] args) {
        int[][][] array = new int[1][0][-1];
    }
}

Exception in thread "main" java.lang.NegativeArraySizeException: -1
```

这段代码能够正常编译，但运行时会报`NegativeArraySizeException`异常，在 Java 虚拟机规范中明确规定了`NegativeArraySizeException`是一个**运行时异常（非检查时异常）**，通俗说就是只要代码不运行到这一行就不会有问题。与运行时异常相对应的是**非运行时异常（检查时异常）**，如果不处理，程序就不能编译通过。

而在 C 语言中，相同语义的代码在编译期就会报错

```c
int main(void) {
    int i[1][0][-1]; // size of array is negative
    return 0;
}
```

由此可见，每种语言的检查行为在运行期还是在编译期进行没有必然的因果逻辑关系，关键是语言规范中认为规定的。

再举一个例子来解释`类型检查`，例如下面一句代码

```java
obj.println("hello world");
```

对于计算机来说，这一行代码“没头没尾”是无法执行的，他需要一个具体的上下文才有讨论的意义。

假设这行代码是在 Java 语言中，并且变量 obj 的静态类型为`java.io.printStream`，那变量 obj 的实际类型就必须是`printStream`的子类（实现了`PrintStream`接口的类）才是合法的，否则，哪怕 obj 属于一个确实有用`println(String)`方法，但与`printStream`接口没有继承关系，代码依然不可能运行——因为类型检查不合法

但是相同的代码在 JavaScript 中情况则不一样，无论 obj 具体是何种类型，只要这种类型的定义中确实包含有`println(String)`方法那方法调用便可成功

这种差别产生的原因是 Java 语言在编译期已将`println(String)`方法完整的符号引用（本例中为一个`CONSTANT_InterfaceMethodref_info`常量）生成出来，作为方法调用指令的参数存储到 Class 文件中，例如下面这段代码

```proper
invokevirtual   #4; //Method java/io/PrintStream.println(Ljava/lang/String;)V
```

这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，虚拟机可以翻译出这个方法的直接引用。而**在 Java Script 等动态语言中，变量 obj 本身是没有类型的，变量 obj 的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。**`变量无类型而变量值才有类型`这个特点也是动态类型语言的一个**重要特征**

动态和静态类型语言都有自己的优点，选择哪种语言是需要经过权衡的

* 静态类型语言的优点：在编译期确定类型，最显著的好处是在编译器可以提供严谨的类型检查，这样与类型相关的问题能在编码的时候就及时发现，利于稳定性及代码达到更大规模
* 动态类型语言的优点：这可以为开发人员提供更大的灵活性，某些在静态类型语言中需要大量“臃肿”代码实现的功能，有动态类型语言来实现可能会更加清晰和简洁，清晰和简洁通常也就意味着开发效率的提升

### JDK1.7 与动态类型

目前确实已经有许多动态了性语言运行于 Java 虚拟机之上了，如`Clojure`/ `Groovy`/ `Jython`/ `JRuby`等，能够在同一个虚拟机上可以达到静态类型语言的严谨性与动态类型语言的灵活性

但遗憾的是，Java 虚拟机层面对动态类型语言的支持一直都有所欠缺，主要表现在方法调用方面：JDK 1.7 以前的字节码指令集中，4条方法调用指令

* `invokevirtual`
* `invokespecial`
* `invokestatic`
* `invokeinterface`

的第一个参数都是被调用的方法的符号引用（`CONSTANT_Methodref_info`或者`CONSTANT_InterfaceMethodref_info`常量），前面已经提到过，**方法的符号引用在编译时产生，而动态类型语言只有在运行期确定接收者类型。**这样，在 Java 虚拟机上实现的动态类型语言就不得不使用其他方式（如编译时留个占位符类型，运动时动态生成字节码实现具体类型到占位符类型的适配）来实现，这样势必让动态类型语言实现的复杂度增加，也可能带来额外的性能或者内存开销。尽管可以利用一些方法（如 Call Site Caching）让这些开销尽量变小，但这种底层问题终归是应当在虚拟机层次上去解决才是最合适，因此在 Java 虚拟机层面上提供动态类型的直接支持就成为了 Java 平台的发展趋势之一

### `Java.lang.invoke`包

JDK 1.7 实现了 JSR-292，新加入了`java.lang.invoke`包就是 JSR-292 的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为`MethodHandle`。

Java 的`MethodHandle`与 C/C++ 的`Function Pointer`类比

C/C++实现一个带谓词的排序，将谓词定义为函数，用函数指针把谓词传递到排序方法

```c
void sort(int list[], const int size, int (*compare)(int, int))
```

Java 语言做不到这一点，没有办法单独地把一个函数作为参数进行传递，普遍的做法是设计一个带有`compare()`方法的`Comparator`接口，以实现了这个接口的对喜爱那个作为参数，例如`Collections.sort()`就是这样定义的：

```java
void sort(List list, Comparator c)
```

在拥有`MethodHandle`之后，Java 语言也可以拥有类似于函数指针或者委托的方法别名工具了。

```java
public class MethodHandleDemo {
    static class ClassA {
        public void println(String s) {
            System.out.println("ClassA execute " + s);
        }
    }

    public static void main(String[] args) throws Throwable {
        Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();
        // 无论 obj 最终是哪个实现类，下面这句都能正确调用到 println 方法
        getPrintlnMH(obj).invokeExact("yczuoxin");
    }

    private static MethodHandle getPrintlnMH(Object receiver) throws Throwable {
        // MethodType：代表“方法类型”，包含了方法的返回值(methodType()的第一个参数)和
        // 具体参数(methodType()的第二个及以后的参数)
        MethodType mt = MethodType.methodType(void.class, String.class);
        // lookup()方法来自于methodHandles.lookup,这句的作用是在指定类中查找符合给定的
        // 方法名称、方法类型，并且符合调用权限的方法句柄
        // 因为这里调用的是一个虚方法，按照 Java 语言的规则，方法第一个参数是隐式的，
        // 代表该方法的接收者，也即是 this 指向的对象，这个参数以前是放在参数列表中进行传递的，
        // 而现在提供了 bingTo()发那个发来完成这件事情
        return lookup().findVirtual(receiver.getClass(), "println", mt).bindTo(receiver);
    }
}

// 可能输出 yczuoxin 或 ClassA execute yczuoxin
```

实际上，方法`getPrintlnMH()`中模拟了`invokevirtual`指令的执行过程，只不过它的分派逻辑并非固化在 Class 文件的字节码上，而是通过一个具体的方法来实现，而这个方法本身的返回值（`MethodHandle`对象），可以视为队最终掉哦用方法的一个“引用”，以此为基础，有了`MethodHandle`就可以写出类似于下面这样的函数声明

```java
void sort(List list, MethodHandle compare)
```

`MethodHandle`与`Reflection`有众多相似之处，但是，他们还是有以下**区别**

* 从本质上讲，`Reflection`和`MethodHandle`机制都是在虚拟方法调用，但`Reflection`是**模拟 Java 代码层次**的方法调用，而`MethodHandle`是在**模拟字节码层次**的方法调用。在`MethodHandles.lookup`中的 3 个方法——`findStatic()`、`findVirtual()`、`findSpecial()`正是为了对应于`invokestatic`、`invokevirtual & invokeinterface`和`invokespecial`这几条字节码指令的**执行权限**校验行为，而这些底层细节在使用`Reflection API`时是不需要关心的
* `Reflection`中的`java.lang.reflect.Method`对象远比`MethodHandle`机制中的`java.lang.invoke.MethodHandle`对象所包含的信息多。前者是方法在 Java 一段的全面印象，包含了方法的签名、描述符以及方法属性表中各种属性的 Java 端表示方式，还包含执行权限等的运行期信息。而后者仅仅包含与执行方法相关的信息。用通俗的话来讲，**`Reflection`是重量级，而`MethodHandle`是轻量级**
* 由于`MethodHandle`是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化（如方法内联），在`MethodHandle`上也应当可以采用类似思路去支持（但目前实现还不完善），而通过反射去调用方法则不行
* `Reflection API`的设计目标是只为 Java 语言服务的，而`MethodHandle`则设计成可服务于所有 Java 虚拟机之上的语言，其中也包括 Java 语言

### `invokedynamic`指令

JDK 1.7 为了更好地支持动态类型语言，引入了第 5 条方法调用的字节码指令`invokedynamic`，在使用弄个`MethodHandle`的示例代码反编译后也不会看见`invokedynamic`的身影，它的应用支持在哪里？

在某种程度上，`invokedynamic`指令与`MethodHandle`机制的作用是一样的，都是为了解决原有 4 条`invoke*`指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（包含其他语言的设计者）有更高的自由度。而且，它们两者的思路也是可类比的，可以把他们想象成为了达成同一个目的，一个采用上层 Java 代码和 API 来实现，另一个用字节码和 Class 中的其他属性、常量来完成。因此，如果理解了前面的`MethodHandle`例子，那么理解`invokedynamic`指令也不困难

每一处含有`invokedynamic`指令的位置都称作`动态调用点Dynamic Call Site`，这条指令的第一个参数不再是代表方法符号引用`CONSTATN_Methodref_info`常量，而是变为 JDK 1.7 新加入的`CONSTANT_InvokeDynamic_info`常量，从这个新常量中可以得到 3 项信息：

* 引导方法`Bootstrap Method`，此方法存放在新增的`BootstrapMethods`属性中
* 方法类型`MethodType`
* 方法名称

引导方法是有固定的参数，并且返回值是`java.lang.invoke.CallSite`对象，这个代表真正要执行的目标方法调用。根据`CONSTANT_InvokeDynamic_info`常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个`ClassSite`对象，最终调用要执行的目标方法，从而获得一个`CallSite`对象，最终调用要执行的目标方法。

```java
public class InvokeDynamicDemo {
    public static void main(String[] args) throws Throwable {
        INDY_BootstrapMethod().invokeExact("yczuoxin");
    }

    public static void testMethod(String s) {
        System.out.println("hello String: " + s);
    }

    public static CallSite BootstrapMethod(MethodHandles.Lookup lookup,
                                            String name,
                                            MethodType mt) throws Exception {
        return new ConstantCallSite(lookup.findStatic(InvokeDynamicDemo.class, name, mt));
    }

    private static MethodType MT_BootstrapMethod() {
        return MethodType.fromMethodDescriptorString
                ("(Ljava/lang/invoke/MethodHandles$Lookup;" +
                        "Ljava/lang/String;" +
                        "Ljava/lang/invoke/MethodType;)" +
                        "Ljava/lang/invoke/CallSite;", null);
    }

    private static MethodHandle MH_BootstrapMethod() throws Exception {
        return lookup().findStatic(InvokeDynamicDemo.class,
                "BootstrapMethod",
                MT_BootstrapMethod());
    }

    private static MethodHandle INDY_BootstrapMethod() throws Throwable {
        CallSite cs = (CallSite) MH_BootstrapMethod().invokeWithArguments(lookup(),
                "testMethod",
                MethodType.fromMethodDescriptorString("(Ljava/lang/String;)V", null));
        return cs.dynamicInvoker();
    }
}

hello String: yczuoxin
```

由于`invokedynamic`指令所面向的使用者并非 Java 语言，而是其他 Java 虚拟机之上的动态语言，因此仅依靠Java 语言编译器 Javac 没有办法生存带有`invokedynamic`指令的字节码（曾经有一个`java.dyn.InvokeDynamic`的语法糖可以实现，但后来被取消了），所以要使用 Java 语言来演示`invokedynamic`指令只能用一些变通的办法。John Rose 编写了一个把程序的字节码转换为使用`invokedynamic`的简单工具 INDY 来完成这件事情，我们要使用这个工具来产生最终要的字节码，因此这个实例代码中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为他们是要被 INDY 工具（没找到，所以不赘述了）读取的

### 掌控方法分派规则

`invokedynamic`指令与前面 4 条`invoke*`指令最大的差别就是它的分派逻辑不是由虚拟机决定的，而是有程序员决定。

```java
public class Test {
    public static void main(String[] args) {
        (new Test().new Son()).thinking();
    }

    class GrandFather {
        void thinking() {
            System.out.println("I am grandfather");
        }
    }

    class Father extends GrandFather {
        @Override
        void thinking() {
            System.out.println("I am father");
        }
    }

    class Son extends Father {
        @Override
        void thinking() {
            try {
                MethodType mt = MethodType.methodType(void.class);
				MethodHandle mh = MethodHandles.lookup().findSpecial(GrandFather.class, "thinking", mt, getClass());
				mh.invoke(this);
            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }
        }
    }
}

I am father
```

书上说可以调用到祖父类的方法，然而我尝试后是没用的，具体什么原因没有细看