# 字节码指令简介

## 概述

### Java虚拟机

由操作码和操作数组成

* **操作码（Opcode）**
  * **由一个字节长度的、代表着某种特定操作含义的数字**
* **操作数（Operands）**
  * **以及紧跟操作码的零至多个代表此操作所需参数**

Java虚拟机采用面向的操作数栈而不是寄存器的架构，所以大多数指令都不含操作数，只有一个操作码

### 字节码指令集

一种具有鲜明特点、优劣势都很突出的指令集架构

#### 劣势

* 由于限制了 Java 虚拟机操作码的长度为一个字节，这意味着操作码总数不能超过 256 条
  * 由于 Class 文件放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，如果将一个 16 位字节长度的无符号字节存储起来（`byte1`，`byte2`），那么他们的值应该是这样的 -> `（byte1 << 8 | byte2)`，这样做会损失性能

#### 优势

* 放弃了操作数长度对齐，意味着可以省略很多填充和间隔符号
  * 用一个字节来代表操作码，也是尽可能获得短小精干的编译代码。这种尽可能小数据量、高传输效率的设计是由Java语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今

### 基本的执行模型

```java
do {
    自动计算PC寄存器的值加1;
    根据PC寄存器的指示位置，从字节码流中取出操作码;
    if (字节码存在操作数)从字节码流中取出操作数;
    执行操作码所定义的操作;
} while (字节码流长度 > 0);
```

## 字节码与数据类型

指令集中，大多数指令都包含了其操作所对应的数据类型信息。如`iload`指令用于从局部变量表中加载`int`型的数据到操作数栈中，而`aload`指令用于从局部变量表中加载`reference`型数据。

这两条指令的操作在虚拟机中可能会是同一段代码来实现，但在 Class 文件中他们必须拥有各自独立的操作码。

* 大部分与数据类型相关的字节码指令 的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务

| 数据类型  | 助记符 |
| :-------: | :----: |
|    int    |   i    |
|   long    |   l    |
|   short   |   s    |
|   byte    |   b    |
|   char    |   c    |
|   float   |   f    |
|  double   |   d    |
| reference |   a    |

* 也有一些指令的助记符没有明确的指明操作类型的字母，如`arraylength`指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数据类型的对象。
* 还有一些指令，如无条件跳转指令`goto`则是与数据类型无关的。

由于 Java 虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来很大的压力。因此，**Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它**，换句话说，指令集将会故意被设计成非完全独立的（ Java 虚拟机规范中把这种特性称为`Not Orthogonal`，即并非每种数据类型和每一种操作都有相应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。

### Java 虚拟机指令集所支持的数据类型

|   opcode   |  byte   |  short  |    int     |  long   |  float  | double  |  char   | reference  |
| :--------: | :-----: | :-----: | :--------: | :-----: | :-----: | :-----: | :-----: | :--------: |
|   Tipush   | bipush  | sipush  |            |         |         |         |         |            |
|   Tconst   |         |         |   iconst   | lconst  | fconst  | dconst  |         |   aconst   |
|   Tload    |         |         |   iload    |  lload  |  fload  |  dload  |         |   aload    |
|   Tstore   |         |         |   istore   | lstore  | fstore  | dstore  |         |   astore   |
|    Tinc    |         |         |    iinc    |         |         |         |         |            |
|   Taload   | baload  | saload  |   iaload   | laload  | faload  | daload  | caload  |   aaload   |
|  Tastore   | bastore | sastore |  iastore   | lastore | fastore | dastore | castore |  aastore   |
|    Tadd    |         |         |    iadd    |  ladd   |  fadd   |  dadd   |         |            |
|    Tsub    |         |         |    isub    |  lsub   |   sub   |  dsub   |         |            |
|    Tmul    |         |         |    imul    |  lmul   |  smul   |  dmul   |         |            |
|    Tdiv    |         |         |    idiv    |  ldiv   |  sdiv   |   div   |         |            |
|    Trem    |         |         |    irem    |  lrem   |  srem   |  drem   |         |            |
|    Tneg    |         |         |    ineg    |  lneg   |  sneg   |  dneg   |         |            |
|    Tshl    |         |         |    ishl    |  lshl   |         |         |         |            |
|    Tshr    |         |         |    ishr    |  lshr   |         |         |         |            |
|   Tushr    |         |         |   iushr    |  lushr  |         |         |         |            |
|    Tand    |         |         |    iand    |  land   |         |         |         |            |
|    Tor     |         |         |    ior     |   lor   |         |         |         |            |
|    Txor    |         |         |    ixor    |  lxor   |         |         |         |            |
|    i2T     |   i2b   |   i2s   |            |   i2l   |   i2f   |   i2d   |         |            |
|    l2T     |         |         |    l2i     |         |   l2f   |   l2d   |         |            |
|    f2T     |         |         |    f2i     |   f2l   |         |   f2d   |         |            |
|    d2T     |         |         |    d2i     |   d2l   |   d2f   |         |         |            |
|    Tcmp    |         |         |            |  lcmp   |         |         |         |            |
|   Tcmpl    |         |         |            |         |  fcmpl  |  dcmpl  |         |            |
|   Tcmpg    |         |         |            |         |  fcmpg  |  dcmpg  |         |            |
| if_TecmpOP |         |         | if_iecmpOP |         |         |         |         | if_aecmpOP |
|  Treturn   |         |         |  ireturn   | lreturn | return  | dreturn |         |  areturn   |

通过使用数据类型列所代表的特殊字符替换 opcode 列的指令模板中的`T`，就可以得到一个具体的字节码指令。如果在表中**指令模板**与**数据类型**两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。

可以看出大部分的指令都没有支持中枢类型的`byte`、`char`和`short`，甚至没有任何指令支持`boolean`类型。编译器会在编译期或运行期将`byte`和`short`类型的数据带符号扩展（ Sign - Extend ）为相应的`int`类型数据，将`boolean`和`char`类型数据零位扩展（ Zero - Extend ）为相应的`int`类型数据。因此。大多数对于`boolean`、`byte`、`short`和`char`类型数据的操作，实际上都是使用相应的`int`类型作为运算类型（Computational Type）。

## 加载和存储指令

**加载和存储指令用于将数据在栈桢中的局部变量表和操作数栈直接来回传输**

* 将一个**局部变量**加载到**操作栈**
  * `iload`、`iload_<n>`、`lload`、`lload_<n>`、`fload`、`fload_<n>`、`dload`、`dload_<n>`、`aload`、`aload_<n>`
* 将一个数值从**操作数栈**存储到**局部变量表**
  * `istore`、`istore_<n>`、`lstore`、`lstore_<n>`、`fstore`、`fstore_<n>`、`dstore`、`dstore_<n>`、`astore`、`astore_<n>`
* 将一个**常量**加载到**操作数栈**
  * `iconst`、`iconst_<n>`、`lconst`、`lconst_<n>`、`fconst`、`fconst_<n>`、`dconst`、`dconst_<n>`、`aconst`、`aconst_<n>`
* **扩展局部变量表**的访问索引的指令
  * `wide`

存储数据的操作数栈和局部变量表主要是由加载和存储指令进行操作，除此之外，也有不少指令，日访问对象的字段或数组元素的指令也会向操作数栈传输数据

上面的助记符中，有一部分是以尖括号结尾的（例如`iload<n>`）,这些指令助记符实际上代表了一组指令（例如`iload<n>`，它代表了`iload_0`、`iload_1`、`iload_2`和`iload_3`这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如`iload`）的特殊形式，对于这若干组特殊指令来说，他们省略掉了显式的操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。除了这点之外，他们的语义与原生的通用指令完全一致（例如`iload_0`的语义与操作数为0时的`iload`指令语义完全一致）。

## 运算指令

运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶

大体上算术指令可以分为两种

* 对整型数据进行运算的指令
* 对浮点型数据进行运算的指令

无论是哪种算术指令，都是用 Java 虚拟机的数据类型，对于`byte`、`short`、`char`、`boolean`类型的算术指令，对于这类数据的运算，应使用操作`int`类型的指令代替。

* 加法指令：`iadd`、`ladd`、`fadd`、`dadd`
* 减法指令：`isub`、`lsub`、`fsub`、`dsub`
* 乘法指令：`imul`、`lmul`、`fmul`、`dmul`
* 除法指令：`idiv`、`ldiv`、`fdiv`、`ddiv`
* 求余指令：`irem`、`lrem`、`frem`、`drem`
* 取反指令：`ineg`、`lneg`、`fneg`、`dneg`
* 位移指令：`iadd`、`ladd`、`fadd`、`dadd`
* 按位或指令：`ishl`、`ishr`、`iushr`、`lshl`、`lshr`、`lushr`
* 按位与指令：`ior`、`lor`
* 按位异或指令：`ixor`、`lxor`
* 局部变量自增指令：`iinc`
* 比较指令：`dempg`、`dempl`、`fempg`、`fempl`、`lemp`

数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数，Java 虚拟机没有定义过数据溢出的具体运算结果，仅规定了在处理整型数据时，**只有**除法指令（`idiv`和`ldiv`）以及求余指令（`irem`和`lrem`）中当出现除数为零时会导致虚拟机抛出`ArithmeticException`异常。

Java 虚拟机要求虚拟机在进行浮点型数据运算时，必须严格遵循`IEEE754规范`中所规定的行为和限制。也就是说，Java 虚拟机必须完全支持`IEEE754`中定义的**非正规浮点数值（Denormalized Floating-Point Numbers）**和**逐级下降（Gradual Underflow）**的运算规则。所有的运算结果都**必须**舍入到适当的精度，非精度的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将选择最低有效位为零的。这种舍入模式也是`IEEE754规范`中的默认舍入模式，称为**向最接近数舍入模式**（向偶数舍入，他将数字向上或向下舍入，使得结果的有效数字是偶数，在中间值时，50%时间向下取整，50%时间向上取整）。

把浮点型数转换为整数时，使用**向零舍入模式**，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式在目标数值类型中选择一个最近但是不大于原值的数字来作为最精确的舍入结果。

Java 虚拟机在处理浮点数运算时，不会抛出任何运行时异常（Java 语言中的异常，`IEEE754规范`中的浮点异常是一种运算符号）。当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作没有明确的数学定义的话，将会使用`NaN`值来表示。所有使用`NaN`值作为操作数的算术操作，结果都会返回`NaN`。

在`long`类型数值进行比较的时候，虚拟机采用的带符号的比较方式，而对浮点型数值进行比较时（`dempg`、`dempl`、`fempg`、`fempl`），虚拟机采用`IEEE754规范`所定义的无符号比较（Nonsignaling Comparisons）方式。

## 类型转换指令

类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显示类型转换操作，或者用来处理本节开篇所提到的字节码指令集中国年数据类型的相关指令无法与数据类型一一对应的问题

Java虚拟机直接支持的宽化类型转换（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）：

* `int` -> `long`/`float`/`double`
* `long` -> `float`/`double`
* `float` -> `double`

处理窄化类型转换（Narrowing Numeric Conversions）时，必须显示的使用转换指令来完成，这些指令包括：

* `i2b`
* `i2c`
* `i2s`
* `l2i`
* `f2i`
* `f2l`
* `d2i`
* `d2l`
* `d2f`

窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失

在将`int`或`long`类型转换为整数类型 T 时，转换过程仅仅是简单的丢弃最低位 N 个字节以外的内容，N 是类型 T 的数据类型长度，这可能导致转换结果和输入值有不同的正负号

再将一个浮点值窄化转换为整数类型 T（T 限于`int`或`long`类型之一）的时候，将遵循一下转换规则

* 如果浮点型是`NaN`, 那转换结果就是`int`或`long`类型的`0`
* 如果浮点值不是无穷大的话，浮点值使用`IEEE754`的向零舍入模式取整。获得整数值 v, 如果 v 在目标类型 T （`int`或`long`）的表示范围之内，那转换结果就是 v
* 否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小整数

从`double`类型到`float`类型的窄化转换过程与`IEEE754`中定义的一致，通过`IEEE754`向最接近数舍入模式舍入得到一个可以使用`float`类型表示的数字，如果转换结果的绝对值太小而无法使用`float`来表示，将返回`float`类型的正负无穷大，对于`double`类型的`NaN`值将按规定转换为`float`类型的`NaN`值



## 对象创建与访问指令

虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下

* 创建类实例的指令：`new`
* 创建数组的指令：`newarray`/`anewarray`/`multianewarray`
* 访问类字段（`static`字段，或者成为类变量）和实例字段（非`static`字段，或者称为实例变量）的指令：`getfield`/`putfield`/`getstatic`/`putstatic`
* 把一个数组元素加载到操作数栈的指令：`baload`/`caload`/`saload`/`iaload`/`laload`/`faload`/`daload`/`aaload`
* 将一个操作数栈的值存储到数组元素中的指令：`bastore`/`castore`/`sastore`/`iastore`/`lastore`/`fastore`/`dastore`/`aastore`
* 取数组长度的指令：`arraylength`
* 检查类实例类型的指令：`instanceof`/`checkcast`



## 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令，包括：

* 将操作数栈的栈顶一个或两个元素出栈：`pop`/`pop2`
* 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：`dup`/`dup2`/`dup_x1`/`dup2_x1`/`dup_x2`/`dup2_x2`
* 将栈最顶端的两个数值互换：`swap`



## 控制转移指令

控制转移指令可以让 Java 虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，可以认为控制转移指令就是在有条件或无条件的修改 PC 寄存器的值。控制转移指令如下：

* 条件分支：`ifeq` /`iflt` /`ifle` /`ifgt` /`ifge` /`ifnull` /`ifnonnull  ` /`if_icmoeq` /`if_icmplt` /`if_icmpgt` /`if_icmple` /`if_icmpge ` /`if_acmpeq` /`if_acmpne`
* 复合条件分支：`tableswitch` /`lookupswitch`
* 无条件分支：`goto` /`goto_w` /`jsr` /`jsr_w` /`ret`

Java 虚拟机中有专门的指令集来处理`int`和`reference`类型的条件分支比较操作，为了可以无需明显标识一个实体值是否`null`，也有专门的指令用来检测`null`值

与前面算术运算时的规则一致，对于`boolean`类型、`byte`类型、`char`类型和`short`类型的条件分支计较操作，都是使用`int`类型的比较指令来完成，对于`long`类型、`float`类型和`double`类型的条件分支比较操作，则会先执行相应类型的比较运算指令（`dcmpg` /`decml` /`fcmpg` /`lcmp`），运算指令会返回一个整型值到操作数栈中，随后再运行`int`类型的条件分支比较操作来完成整个分支跳转。Java 虚拟机提供的`int`类型的条件分支指令是最为丰富的和强大的



## 方法调用和返回指令

以下5条用于方法调用的指令：

* `invokevirtual`指令用于调用**对象的实例方法**，根据对象的实际类型进行分派（虚方法分派），这也是 Java 语言中最常见的方法分派方式
* `invokeinterface`指令用于调用**接口方法**，他会在运行时搜索一个实现了这个接口的方法的对象，找出合适的方法进行调用
* `invokespecial`指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法
* `invokestatic`指令用于调用类方法（static 方法）
* `invokedynamic`指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法

前面4条调用指令的分派逻辑都固化在 Java 虚拟机内部，而`invokedynamic`指令的分派逻辑是有用户所设定的引导方法决定的

**方法调用指令**与**数据类型无关**，而**方法返回指令**是**根据返回值的类型区分**的，包括`ireturn`（当返回值是`boolean` /`byte` /`char` /`short` /`int`类型时使用） /`lreturn` /`freturn` /`dreturn` /`areturn`，另外还有一条`return`指令供声明为`void`的方法、实力初始化方法以及类和接口的类初始化方法使用



## 异常处理指令

Java 程序中显式的抛出异常的操作（`throw`语句）都由`athrow`指令来实现，除了用`throw`语句显式抛出异常情况之外，Java 虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令监测到异常状况时自动抛出。例如，在前面介绍的整数运算中，当除数为零时，虚拟机会在`idiv`或`ldiv`指令中抛出`ArithmeticException`异常

Java 虚拟机中，处理异常（`catch`语句）不是由字节码指令来实现的，而是采用异常表来完成的



## 同步指令

Java 虚拟机可以支持**方法级的同步**和**方法内部一段指令序列的同步**，这两种同步结构都是使用**管程（`Monitor`**

**）**来支持的

**方法级的同步是隐式的**，无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的`ACC_SYNCHRONIZED`访问标志符得知一个方法是否被声明为同步方法。当方法调用时

* 调用指令将会检查方法的`ACC_SYNCHRONIZED`访问标志是否被设置
  * 如果设置了执行线程就要求**先成功持有管程**，然后才能执行方法，最后当**方法完成（无论是正常完成还是非正常完成）时释放管程**。

同步一段指令集序列通常由 Java 语言中的`synchronized`语句块来表示。Java 虚拟机的指令集中有`monitorenter`和`monitorexit`两条指令来支持`synchronized`关键字的语义。正确实现`synchronized`关键字需要**`Javac`编译器与 Java 虚拟机两者共同协作**支持

如下代码

```java
void onlyMe (Foo f) {
    synchronized (f) {
        doSomething ();
    }
}
```

编译后的字节码序列如下

|                 |                                                |
| --------------- | ---------------------------------------------- |
| 0 aload_1       | 将对象 f 入栈                                  |
| 1 dup           | 复制栈顶元素（即 f 的引用）                    |
| 2 astore_2      | 将栈顶元素存储到局部变量表 Slot 2 中           |
| 3 monitorenter  | 以栈顶元素（即 f）作为锁，开始同步             |
| 4 aload_0       | 将局部变量 Slot 0（即 this 指针）的元素入栈    |
| 5 invokevirtual | 调用 doSomething () 方法                       |
| 8 aload_2       | 将局部变量 Slot 2 的元素（即 f）入栈           |
| 9 monitorexit   | 退出同步                                       |
| 10 goto 18      | 方法正常结束，跳转到 18 返回                   |
| 13 astore_3     | 从这步开始是异常路径，见下面异常表的 Target 13 |
| 14 aload_2      | 将局部变量 Slot 2 元素（即 f）入栈             |
| 15 monitorexit  | 退出同步                                       |
| 16 aload_3      | 将局部变量 Slow 3 的元素（即异常对象）入栈     |
| 17 athrow       | 将异常对象重新抛给 onlyMe () 方法的调用者      |
| 18 return       | 方法正常返回                                   |

```properties
Exception table
FromTo	Target	Type
4		10		13		any
13		16		13		any
```

编译器必须确保无论方法通过任何方式完成，方法中调用过的每条`monitorenter`指令都必须执行器对应的`monitorexit`指令，而无论这个方法时正常结束还是异常结束

从上述字节码序列中可以看到，为了保证在方法异常完成时`monitorenter`和`monitorexit`指令依然可以正确配对执行，编译器会**自动产生一个异常处理器，它的目的就是用来执行`monitorexit`指令**