

# Java内存区域

## 运行时数据区域

* 程序计数器(线程私有)
* 虚拟机栈(线程私有)
* 本地方法栈(线程私有)
* 堆(线程共享)
* 方法区(线程共享)

### 程序计数器

* 定义
  * 一块内存较小的空间,可以看作是当前线程所执行的字节码行号指示器,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.可以保证线程切换后能恢复到正确的执行位置.
* 特点
  * 每个线程都有自己独立的程序计数器(线程私有)
  * 在运行native方法时,计数器值为空(undefined)
  * 唯一一个没有OOM情况的区域

### java虚拟机栈

* 定义

  * 描述java方法执行的内存模型,每个方法在执行的时候都会创建一个栈桢,每个方法从调用直到执行完成,对应的栈桢在虚拟机栈中入栈到出栈.

* 特点

  * 每个线程都有自己独立的程序计数器(线程私有)
  * 生命周期与线程相同
  * 线程请求的栈深度大于虚拟机允许的深度,将抛出StackOverflowError
  * 虚拟机栈动态扩展时申请不到足够的内存,将会抛出OOM.

* 结构

  * 局部变量表(所谓的栈)

  * 栈桢

  * 动态链接

  * 方法出口

    ...

### 本地方法栈

* 定义
  * 与虚拟机栈作用相类似,只不过虚拟机栈为执行java方法服务,而本地方法栈为虚拟机使用的native方法服务,虚拟机对本地方法使用的语言,使用方式和数据结构没有强制规定,虚拟机可以自由实现它.HotShot直接把本地方法栈和虚拟机栈合二为一.
* 特点
  * 与虚拟机栈一样

### java堆

* 定义
  * 虚拟机管理的最大一块内存,在虚拟机启动时创建,存在的唯一目的就是存放对象
* 特点
  * 线程共享,但是也会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)
  * 随着JIT编译器的发展和逃逸分析技术逐渐成熟.栈上分配,标量替换优化技术将会导致一些微妙的变化产生,所有的对象都分配在堆上也渐渐变得不是那么'绝对'了
  * 垃圾收集器管理的主要区域,可以细分为新生代,老年代.再细致一点就是Eden空间,From Survivor空间和 To Surviver空间.
  * 堆可以处于物理上不连续的内存空间中,只要逻辑上连续就可以
  * 堆可以自动扩展,当堆无法再扩展时,就会抛出OOM

### 方法区(Non-Heap)

* 定义
  * 又被称为永久带,用于储存已被虚拟机加载的类信息,常量,静态变量和已被编译的代码等数据
* 特点
  * HotShot把GC区域扩展至方法区,省去了为方法区编写GC方法,1.7的JDK已经把字符串常量池移出永久带.
  * 被GC的机会很少,主要是针对常量池的回收和类型的卸载.但是这个区域的垃圾回收很难令人满意,尤其是类型的卸载
  * 当方法区无法满足分配要求时,将抛出OOM.

### 运行时常量池

* 定义
  * 方法区的一部分,用于存放编译期生成的各种字面量和符号引用,还会把翻译出来的直接引用也存储与运行时常量池
* 特点
  * 具备动态性,运行期间也可以将新的常量放入池中(例如String.intern())
  * 方法区一部分,也会在相同情况下抛出OOM

### 直接内存

* 定义
  * JDK1.4中引入的NIO类,引入了通道与缓冲区的I/O方式,他可以使用Native函数库直接分配堆外内存,然后通过java堆中的DirectByteBuffer对象作为这块内存的引用进行操作,避免了Java堆和Native堆中来回复制数据.
* 特点
  * 不会受到Java堆配置的内存大小限制,但是会受到本机内存(包括RAM一级SWAP区或者分页文件)的限制及处理器寻址空间的限制.
  * 动态扩展时可能会出现OOM

### 元数据区(jdk 1.8)

* 定义
  * 在JDK1.8中移除了永久带(方法区)并加入了元数据区,使用本地内存来存储元数据信息.
* 特点
  * 不会出现`java.lang.OutOfMemoryError: PermGen`,取而代之的是`java.lang.OutOfMemoryError: Metadata space`
  * 默认是不受限制(当然还是受到机器的内存空间限制),可以用`-XX:MaxMetaspaceSize=128m`设定.
  * 如果发生内存泄漏,不会断的吃掉机器的内存.



## HotShot虚拟机对象探秘

### 对象的创建

* 首先去检查这个指令的参数是否能在常量池定位到一个类的符号引用,并检查这个符号引用代表的类是否被加载,解析和初始化过.

* 给这个对象分配内存空间.
  * 内存空间绝对规整: 把用过的内存放在一边,空闲的内存放在另一边.中间放着一个指针作为指示器,分配内存时,就把指针位置向空闲一边挪动对象大小相等的距离.这种方法叫做指针碰撞.
  * 内存空间不规整: 虚拟机维护一个列表,记录哪些内存块可用.分配内存时,从列表中划分出足够大小的内存即可.这种方法叫做空闲列表.
  * 为解决线程不安全的问题
    * 对内存空间的动作做同步处理——采用CAS配上失败重试的方式.
    * 利用本地线程分配缓冲(即上面所说的TLAB),线程分配内存就在自己的TLAB上划分,用完后分配新的TLAB并进行同步锁保证线程安全.

* 将内存空间进行初始化为零值(除了对象头),如果使用TLAB,这个工作可以在提前到TLAB分配时完成.这样就可以在java对象还未赋值时便可使用.只是拿到的都是零值.
* 对对象进行必要的设置,如对象属于哪个类,如何能找到类的元信息,对象的hashCode,对象的GC分代年龄等.此时对于虚拟机而言对象已经创建完成.
* 对对象进行赋值.



### 对象内存布局

#### 对象头(Mark Word)

* 自身运行时数据: 如hashCode, GC年龄代.锁状态,持有锁信息,偏向锁线程ID,偏向时间戳等,例如32位虚拟机下的未被锁定状态下的对象,25bit是对象的hashCode,4bit是GC年龄代,2bit是锁状态,1bit固定值为0.JavaThread是偏向锁线程ID,epoch是偏向时间戳.

```c++
//  32 bits:
//  --------
//  hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
//  size:32 ------------------------------------------>| (CMS free block)
//  PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)
//
//  64 bits:
//  --------
//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
//  size:64 ----------------------------------------------------->| (CMS free block)
//
//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)
//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)
//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)
//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)
```

									HotShot虚拟机对象头

|          存储内容          | 标志位 |        状态        |
| :------------------------: | :----: | :----------------: |
|   对hashCode,对象年龄代    |   01   |       未锁定       |
|      指向锁定位的指针      |   00   |     轻量级锁定     |
|     指向重量级锁的指针     |   10   | 锁膨胀(重量级锁定) |
|     空,不需要记录信息      |   11   |       GC标记       |
| 偏向锁ID,时间戳,对象年龄代 |   01   |       可偏向       |

* 类型指针: 即对象指向自己类元数据的指针,确定这个对象是哪个类的实例.并不是所有的对象数据上保留类型指针(查找对象元信息不一定经过对象本身),例如Java数组,其对象头中必须有一块用于记录数组长度的数据.



#### 实例数据

对象真正存储的有效信息,无论是父类继承的信息还是自己声明的各种类型的字段内容.存储顺序受虚拟机的分配策略参数(FieldAllocationStyle)和字段在Java定义的顺序影响.

HotShot的特性

* 相同宽度的字段总是放在一起
* 父类定义的字段会出现在子类之前
* 若CompactFields被设置为true(默认是true),子类中较窄的变量也可能插入在父类变量的空隙之中.



#### 对齐填充

自动内存管理系统要求对象的大小必须是8的倍数,所以当对象实力部分没有对齐的时候,就要通过对齐填充来补全.



### 对象的访问定位

Java程序需要通过Java栈本地变量表上面的reference(只规定了一个指向对象的引用,没有定义这个引用应该通过何种方式去定位,访问堆中的对象的具体位置)来操作堆.

- 句柄访问
  - Java堆中划出一部分内存作为句柄池,reference存储的就是对象的句柄地址.句柄池(堆)包含了对象的实例数据(堆)和类型数据(方法区)各自的地址信息.
  - 优势
    - reference存储的是稳定的句柄地址.当对象位置改变时,只需要改变句柄实例地址,reference本身不用更改.
- 直接指针访问
  - reference中存储的对象的实例数据地址,在实例数据地址又可以获取到对象的类型数据.
  - 优势
    - 节省了一次指针定位的开销,速度更快.