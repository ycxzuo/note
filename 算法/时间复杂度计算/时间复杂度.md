# 时间复杂度

## 简单规则

### “有限次操作”的时间复杂度往往是O(1)

**例子：交换两个数a和b的值**

```c
void swap(int& a, int& b){
         int t=a;
         a=b;
         b=t;
}
```

**分析**：通过了一个中间变量`t`，进行了 3 次操作，交换了`a`和`b`的值，swap 的时间复杂度是 O(1)。

### “for循环”的时间复杂度往往是O(n)

**例子：n个数中找到最大值**

```c
int max(int[] arr, int n){

         int temp = -MAX;

         for(int i=0;i<n;++i)

                   if(arr[i]>temp) temp=arr[i];

         return temp;

}
```

**分析**：通过一个 for 循环，将数据集遍历，每次遍历，都只执行“有限次操作”，计算的总次数，和输入数据量 n 呈**线性关系**。

### “树的高度”的时间复杂度往往是O(lg(n))

**例子1：在一棵包含n个元素二分查找树上进行**二分查找**，其时间复杂度是O(lg(n))**

**例子2：对一个包含n个元素的堆顶元素弹出后，**调整成一个新的堆**，其时间复杂度也是O(lg(n))**

**分析**：树的总节点个数是 n，则树的高度是 lg(n)



## 组合规则

### 通过简单规则的时间复杂度，来求解组合规则的时间复杂度

**例如：n个数冒泡排序**

```c++
void bubble_sort(int[] arr, int n){
   for(int i=0;i<n;i++)
       for(int j=0;j<n-i-1;j++)
           if(arr[j]>arr[j+1])
                swap(arr[j], arr[j+1]);
}
```

**分析**：冒泡排序，可以看成三个规则的组合：

1. 外层for循环

2. 内层for循环

3. 最内层的swap

故，**冒泡排序**的时间复杂度为：

O(n) * O(n) * O(1) = O(n^2)

**例如：TopK问题，通过建立k元素的堆，来从n个数中求解最大的k个数**

1. 先用前 k 个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素
2. 接着，从第 k+1 个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的 k 个元素，总是当前最大的k个元素
3. 扫描完所有 n-k 个元素，最终堆中的 k 个元素，就是为所求的 TopK

```c++
heap[k] = make_heap(arr[1, k]);
for(i=k+1 to n){
         adjust_heap(heep[k],arr[i]);
}
return heap[k];
```

**分析**：可以看成三个规则的组合：

1. 新建堆

2. for循环

3. 调整堆

故，用**堆求解 TopK**，时间复杂度为：

O(k) + O(n) * O(lg(k)) = O(n*lg(k))



## 递归求解

**案例一：计算 1到n的和，时间复杂度分析**

如果用**非递归的算法**:

```c++
int sum(int n){
         int result=0;
         for(int i=0;i<n;i++)
                   result += i;
         return result;
}
```

根据简单规则，for 循环，sum 的时间复杂度是 O(n)

但如果是**递归算法**，就没有这么直观了：

```c++
int sum(int n){
         if (n==1) return 1;
         return n+sum(n-1);
}
```

用f(n)来表示数据量为n时，算法的计算次数，很容易知道：

- 当 n=1 时，sum 函数只计算1次
- f(n) 的计算次数，等于 f(n-1) 的计算次数，再加1次计算

> f(n)=f(n-1)+1
>
> f(n-1)=f(n-2)+1
>
> …
>
> f(2)=f(1)+1
>
> f(1)=1

上面共n个等式，左侧和右侧分别相加得到

f(n) = n

**案例二：二分查找binary_search，时间复杂度分析**

```c++
int BS(int[] arr, int low, int high, int target){
         if (low>high) return -1;
         mid = (low+high)/2;
         if (arr[mid]== target) return mid;
         if (arr[mid]> target)
                  return BS(arr, low, mid-1, target);
         else
                  return BS(arr, mid+1, high, target);
}
```

**二分查找，单纯从递归算法来分析，怎能知道其时间复杂度是O(lg(n))呢**

用f(n)来表示数据量为n时，算法的计算次数，很容易知道：

- 当 n=1 时，BS 函数只计算 1 次
- f(n) 的计算次数，等于 f(n/2) 的计算次数，再加1次计算

> f (n) = f (n / 2) + 1
>
> f (n / 2) = f (n / 4) + 1
>
> f ( n / 4 ) = f (n / 8)+1
>
> …
>
> f (n / 2 ^ (m - 1)) = f (n / 2 ^ m) + 1

上面共m个等式，左侧和右侧分别相加：

f (n) + f (n / 2) + … + f (n / 2 ^ (m - 1))

=

[f (n / 2) + 1] + [f (n / 4) + 1] + … + [f (n / 2 ^ m)] + [1]

**即得到**：

f (n) = f (n / 2 ^ m) + m

再配合

f(1)=1

**即，n / 2 ^ m = 1时, f (n / 2 ^ m) = 1, 此时 m = lg(n), 这一步，这是分析这个算法的关键**

将 m = lg(n) 带入，**得到**：

f(n) = 1 + lg(n)



**案例三：快速排序 quick_sort，时间复杂度分析**

```c++
void quick_sort(int[]arr, int low, inthigh){
         if (low==high) return;
         int i = partition(arr, low, high);
         quick_sort(arr, low, i-1);
         quick_sort(arr, i+1, high);
}
```

仍用 f(n )来表示数据量为 n 时，算法的计算次数，很容易知道：

- 当 n=1 时，quick_sort 函数只计算1次

- 在n很大时：

  第一步，先做一次 partition；

  第二步，左半区递归；

  第三步，右半区递归；

  即：

  f (n) = n + f (n / 2) + f (n / 2) = n + 2 * f (n / 2)

> *(1)partition本质是一个for，计算次数是n；*
>
> *(2)二分查找只需要递归一个半区，而快速排序左半区和右半区都要递归，这一点在\**分治法**与**减治法**一章节已经详细讲述过；*

式子不断展开

f (n) = n + 2 * f (n / 2)

f (n / 2) = n / 2 + 2 * f (n / 4)

f (n / 4) = n / 4 + 2 * f (n / 8)

…

f (n / 2 ^ (m - 1)) = n / 2 ^ (m - 1) + 2f (n / 2 ^ m)

上面共m个等式，逐步带入，于是得到：

f (n) = n + 2 * f (n / 2)

= n + 2 * [n / 2 + 2 * f (n / 4)] = 2 n + 4 * f (n / 4)

= 2n + 4 * [n / 4 + 2 * f (n / 8)] = 3n + 8f (n / 8)

= …

= m * n + 2 ^ m * f (n / 2 ^ m)

再配合 f (1) = 1 

即，n / 2 ^ m = 1时, f (n / 2 ^ m) = 1, 此时m = lg(n), 这一步，这是分析这个算法的关键

将m = lg(n)带入，**得到：**

f(n) = lg(n) * n + 2 ^ (lg(n)) * f (1) = n * lg(n) + n

故，快速排序的时间复杂度是 n * lg(n)