# I/O 模型

I/O 就是计算机内存与外部设备之间拷贝数据的过程。CPU 访问内存的速度远远高于外部设备，因此 CPU 是先把外部设备，因此 CPU 是先把外部设备的数据读到内存里，然后在进行处理

对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I/O 操作的用户线程，另一个就是操作系统内核。**一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间**

当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤

* 用户线程等待内核将数据从网卡拷贝到内核空间
* 内核数据从内核空间拷贝到用户空间

UNIX 系统的 I/O 模型有 5 种：

* blocking I/O (同步阻塞 I/O)
  * 用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程唤醒
* nonblocking I/O (同步非阻塞 I/O)
  * 用户线程不断发起 read 调用。数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程唤醒
* I/O multiplexing I/O (多路复用)
  * 用户线程的读取操作分成了两步，线程先发起 select 调用，目的是问内核数据准备好了么？等内核把数据准备好了，用户线程再发起 read 调用，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核差多个数据通道 Channel 的状态
* signal driven I/O (信号驱动 I/O)
  * 不常用的 I/O 模型，当网络套接字可读后，内核通过发送 SIGIO 信号通知应用进程，于是应用可以开始读取数据。有时也称此方式为异步 I/O。但是严格讲，该方式并不能算真正的异步 I/O，因为实际读取数据到应用进程缓存的工作仍然是由应用自己负责的
* asynchronous I/O (异步 I/O)
  * 用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞

