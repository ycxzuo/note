# 分布式事务概述

## 事务

### 概念

是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行

### 特性

事务拥有4个特性，也就是所谓的ACID特性

* 原子性（Atomicity）
  * 事务作为一个整体执行，包含在其中的操作要么被执行，要么都不被执行
* 一致性（Consistency）
  * 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态，中间状态不能被察觉
* 隔离性（Isolation）
  * 一个事务所做的修改在最终提交以前，对其他事务是不可见的
* 持久性（Durability）
  * 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的

### 隔离级别

事务拥有4个隔离级别

* Read uncommitted
  * 概念
    * 读未提交，也就是一个事务可以读取另一个未提交事务的数据
  * 造成问题
    * 脏读
* Read committed（Oracle、Sql Server等默认隔离级别）
  * 概念
    * 读提交，也就是一个事务要等另一个事务提交后才能读取
  * 造成问题
    * 不可重复读（Update操作）
* Repeatable read（Mysql默认隔离级别）
  * 概念
    * 重复读，也就是开始事务时，不再允许修改操作
  * 造成问题
    * 幻读（Insert操作）
* Serializable
  * 概念
    * 串行化，事务串行化执行
  * 造成问题
    * 效率低，耗性能

## 分布式事务

### 概念

事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上，通常一个分布式事务中会涉及对多个数据源或业务系统的操作。

### CAP定理

#### 概念

WEB服务无法同时满足以下三个条件

* 一致性（Consistency）
  * 数据在多个副本之间能否保持一致的特性
* 可用性（Availability）
  * 系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果
* 分区容错性（Partition tolerance）
  * 分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障，是基本要求

在一个WEB服务之多只能同时满足以上两个属性，显然，任何横向扩展策略都要依赖于数据分区，因此，设计人员必须在一致性和可用性之间做出选择

### BASE理论

#### 概念

在分布式系统中，我们往往追求可用性，BASE理论的提出，是对CAP定理的一个扩充，它是指

* Basically Available（基本可用）
  * 分布式系统在出现不可预知故障的时候，允许损失部分可用性
    * 响应时间上的损失：例如查询时间由1s在出现故障后变成了5s
    * 系统功能上的损失：例如在双十一的情景下，给用户引导到一个降级页面
* Soft state（软状态）
  * 允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时
* Eventually consistent（最终一致性）
  * 最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态

### 分布式一致性

#### 一致性问题

在分布式系统中要解决的一个重要问题就是数据的复制，因为数据复制需要时间。数据的复制只要是为了满足以下两个需求

* 增加系统的可用性，避免单点故障
* 让每个系统能在不同的地方都能拿到数据副本

#### 数据一致性

就是指在一个数据副本进行更新时能确保所有的数据副本也会更新。

* 解决方案
  * 很容易想到的方案就是在写入的时候使用同步阻塞的方式，完成写入并使数据副本全部同步时再取消阻塞
* 问题诞生
  * 当某个场景有很多写的操作时，会造成整体性能急剧下降

#### 一致性级别

在数据一致性的问题上，看出保证数据的一致性和系统运行的性能是需要考虑和权衡的地方，一致性级别诞生

* 强一致性
  * 如同数据一致性的最初解决方案一样，系统写入的是什么，读出来的就是什么，但是实现起来对系统性能影响极大
* 弱一致性
  * 不承诺多久之后可以读到写入的值，但是数据最终会达到一致的状态
* 最终一致性
  * 弱一致性的一个特例，系统会在一定时间内达到数据一致性，是比较推崇的一种模型

### 分布式环境问题

#### 通信异常

由于网络本身的不可靠性，导致各个服务之间的通信可能出现故障，网络光纤、硬件设备或是系统不可用都会造成网络通信问题，并且单机访问比网络通信要快很多，也会影响到收发过程，导致消息丢失或者延迟

#### 网络分区

* 概念
  * 当网络发生异常情况，导致分布式系统中部分节点之间的网络延迟不断增大，最终导致所有节点中只有部分节点直接可以正常通行

在极端条件下，这些局部小集群需要完成原本整个分布式系统才能完成的功能，包括对数据的事务处理，会对数据一致性产生巨大的挑战

#### 三态

分布式系统的每一次请求与响应，存在特有的三态概念

* 成功
* 失败
* 超时（与单机模式的区别点）
  * 此时发送方无法确定请求是否处理成功
  * 产生超时的情况
    * 该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象
    * 请求成功地被接收方接收后，将响应反馈给发送方的过程中，发生了消息丢失现象

#### 节点故障

指某台服务器节点出现宕机或“僵死”现象

### 常见分布式事务模型

#### X/Open XA协议（XA协议）

##### 模型

```mermaid
graph LR
A[AP应用程序] -->|本地| B[RM资源管理器集群]
A[AP应用程序] -->|TX| C[TM事务管理器]
B[RM资源管理器集群] -->|XA| C[TM事务管理器]
C[TM事务管理器] -->|XA| B[RM资源管理器集群]
```

最早的分布式事务模型是`X/Open`国际联盟提出的`X/Open Distributed Transaction Processing`（`DTP`）模型，`DTP`模型如上图

* 全局事务管理器（TM，`Transaction Manager`）
  * 负责管理全局事务状态与参与的资源，协同资源一起提交或者回滚
* 多个资源管理器（RM，`Reource Manager`）
  * 负责具体资源的操作

##### 流程

* 应用程序（AP，Application）向TM申请开始一个全局事务
* 针对要操作的RM，AP先向TM注册（记录AP操作过哪些RM，及分支事务），TM通过XA接口函数通知相应的RM开启分布式事务的子事务，接着AP就可以对该RM进行操作
* 当AP对所有RM操作完毕后，AP会根据执行情况通知TM提交或回滚该全局事务，TM通过XA接口函数通知各RM完成操作。TM会先要求各个RM做预提交，所有RM返回成功后，再要求RM做正式提交。

##### 原子性

XA协议使用2PC（Two Phase Commit，两阶段提交）原子提交协议来保证分布式事务原子性

* 准备阶段
  * TM向RM发送准备消息，如果RM的本地事务操作执行成功，则返回成功，否则返回失败
* 提交阶段
  * 如果TM收到所有RM回复消息为成功，则向每个RM发送提交消息，否则发送回滚消息；RM根据TM指令执行提交或回滚的本地事务操作，释放事务处理过程中使用的锁资源

##### 隔离性

基于XA协议实现的分布式事务的隔离性是由每个 RM 本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。

例如Mysql使用的2PL（Two-Phase Locking，两阶段锁）机制来控制本地事务的并发，保证隔离性。将锁操作分为加锁和解锁两个阶段，并保证两个阶段完全不相交。加锁阶段，只加锁，不放锁。解锁阶段，只放锁，不加锁

##### 一致性

Mysql通过MVCC（Multi Version Concurrency Control，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各Snapshot对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。

但是在分布式事务中，如果当资源一已提交而资源二还未提交，只能读到资源一上子事务执行的内容，读不到 资源二上的子事务执行的内容，违反了事务一致性的要求。

XA协议没有定义全局Snapshot，官方建议使用串行化的隔离级别来保证分布式事务，但是性能很差，很多分布式数据库都实现了**分布式MVCC机制**来提供全局的一致性读，用一个集中式或者逻辑上单调递增的东西来控制生成全局Snapshot，每个事务或者每条 SQL 执行时都去获取一次，从而实现不同隔离级别下的一致性。比如Google的Spanner就是用TrueTime来控制访问全局Snapshot。

##### 小结

* 优势
  * XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低，对业务几乎都没有侵入
* 缺陷
  * XA无法满足高并发场景，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。



#### TCC模型（Try-Confirm-Cancel）

通过对业务逻辑的分解来实现分布式事务

##### 模型

* 初步操作 try
  * 完成所有业务检查，预留必须的业务资源
* 确认操作 Confirm
  * 真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次
* 取消操作 Cancel
  * 释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性



